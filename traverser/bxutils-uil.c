/*
Copyright (c) 2017, Massachusetts Institute of Technology All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
//static char *cvsrev = "@(#)$RCSfile$ $Revision$ $Date$";
/*
 * WARNING: This file is overwritten at code generation time.
 * Any changes to this file will be lost.
 */
/*
 * MODULE: BxConvert.c
 * AUTHOR: Automatically generated by Builder Xcessory
 * 
 * Description: This module contains various utilities, converters 
 *	for XmStrings (to work properly with app-defaults), and if needed
 *	the XPM pixmap utilities.
 *	
 * Edit the file ${BX}/gen/bxutils.c (BX$SYSTEM:[gen]bxutils.c on VMS) to
 * make system wide changes to this file which will be visible next time
 * this file is generated. 
 * ${BX} is the directory where Builder Xcessory is installed.
 */

/*
 * BX supplies a string format for compound strings:
 *
 *		::[#tag][:t][:r]["str"]
 *
 * where:
 *	:: = indicates compound string.
 *	tag =  the font tag
 *	:t = separator (if not seen no separator added to segment)
 *	:r = right to left (if not seen left to right assumed)
 *	"str" = the text of the string.
 *
 * The components for the compound string can be repeated any number of
 * times.
 */

/*****************************************************************************
 *       INCLUDE FILES
 *****************************************************************************/

#include <Xm/Xm.h>
#include <Xm/RowColumn.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

/*****************************************************************************
 *       TYPDEFS AND DEFINES
 *****************************************************************************/

/*
 * Undefine this if you want to use native strcasecmp.
 */
//#define LOCAL_STRCASECMP

#ifdef _NO_PROTO
#ifdef NeedFunctionPrototypes
#undef NeedFunctionPrototypes
#endif
#endif

/*
 * Define SUPPORTS_WCHARS if the system supports wide character sets
 * Note: the following line flags the VAXC compiler and not the
 * DECC compiler running VAXC emulation. 
 */
#if !((defined(VAXC) && !defined(__DECC)) || defined(__CENTERLINE__))
#define SUPPORTS_WCHARS
#endif

/*
 * Handy definition used in SET_BACKGROUND_COLOR
*/
#define UNSET		(-1)

/*
 * Set state of inclusion of prototypes properly
 */
#ifdef NeedFunctionPrototypes
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#else
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#endif

#ifdef NeedFunctionPrototypes
#ifdef __cplusplus
#define UARG(a, b)	a,
#define GRAU(a, b)	a)
#else
#define UARG(a, b)	a b,
#define GRAU(a, b)	a b)
#endif
#else
#define UARG(a, b)	a b;
#define GRAU(a, b)	a b;
#endif

/*
 * Set up strcasecmp function
 */
#if defined(LOCAL_STRCASECMP)
#define STRCASECMP	StrCasecmp
#ifndef NeedFunctionPrototypes
static int StrCasecmp();
#else
static int StrCasecmp(char *, char *);
#endif
#else
#define STRCASECMP	strcasecmp
#endif

/*
 * Define XTPOINTER so it works with all releases of
 * Xt and c++.
 */
#ifdef __cplusplus
#if XtSpecificationRelease < 5
#define XTPOINTER	char *
#else
#define XTPOINTER	XPointer
#endif
#else
#define XTPOINTER	XtPointer
#endif

/*
 * The following enum is used to support wide character sets.
 * Use this enum for references into the Common Wide Characters array.
 * If you add to the array, ALWAYS keep NUM_COMMON_WCHARS as the last
 * entry in the enum.  This will maintain correct memory usage, etc.
 */
enum { WNull, WTab, WNewLine, WCarriageReturn, WFormFeed, WVerticalTab,
  WBackSlash, WQuote, WHash, WColon, WideF, WideL, WideN, WideR,
  WideT, WideV, WideUF, WideUL, WideUR, WideUT, WideZero, WideOne,
  NUM_COMMON_WCHARS
};

/*****************************************************************************
 *       GLOBAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *       EXTERNAL DECLARATIONS
 *****************************************************************************/

/*****************************************************************************
 *	STATIC DECLARATION
 *****************************************************************************/

#ifndef NeedFunctionPrototypes

#ifndef SUPPORTS_WCHARS
static int mblen();
#endif
static int strlenWc();
static size_t doMbstowcs();
static size_t doWcstombs();
static void copyWcsToMbs();
static int dombtowc();
static Boolean extractSegment();
static XmString StringToXmString();
static char *getNextCStrDelim();
static int getCStrCount();
static wchar_t *CStrCommonWideCharsGet();

#else

#ifndef SUPPORTS_WCHARS
static int mblen(char *, size_t);
#endif
static int strlenWc(wchar_t *);
static size_t doMbstowcs(wchar_t *, char *, size_t);
static size_t doWcstombs(char *, wchar_t *, size_t);
static void copyWcsToMbs(char *, wchar_t *, int, Boolean);
static int dombtowc(wchar_t *, char *, size_t);
static Boolean extractSegment(wchar_t **, wchar_t **, size_t *, wchar_t **, size_t *, int *, Boolean *);
static XmString StringToXmString(char *);
static char *getNextCStrDelim(char *);
static int getCStrCount(char *);
static wchar_t *CStrCommonWideCharsGet();

#endif

/*****************************************************************************
 *	STATIC CODE
 *****************************************************************************/

#if defined(LOCAL_STRCASECMP)

/*
 * Function:
 *      cmp = StrCasecmp(s1, s2);
 * Description:
 *      Compare two strings ignoring case
 * Input:
 *      s1 - char * : string 1 to compare
 *      s2 - char * : string 2 to compare
 * Output:
 *      int :  0; s1 == s2
 *             1; s1 != s2
 */
static int StrCasecmp ARGLIST((s1, s2)) ARG(register char *, s1) GRA(register char *, s2)
{
  register int c1, c2;

  while (*s1 && *s2) {
    c1 = isupper(*s1) ? tolower(*s1) : *s1;
    c2 = isupper(*s2) ? tolower(*s2) : *s2;
    if (c1 != c2) {
      return (1);
    }
    s1++;
    s2++;
  }
  if (*s1 || *s2) {
    return (1);
  }
  return (0);
}
#endif

#ifndef SUPPORTS_WCHARS
/*
 * Function:
 *      len = mblen(s, n);
 * Description:
 *      The mblen function for platforms that don't have one. This
 * 	function simply returns a length of 1 since no wide character
 *	support exists for this platform.
 * Input:
 *      s - char * : the character string to get the length from
 *	n - size_t : the size of the string
 * Output:
 *      int : always 1
 */
static int mblen ARGLIST((s, n)) ARG(char *, s) GRA(size_t, n)
{
  return (1);
}
#endif

/*
 * Function:
 *      len = strlenWc(ptr);
 * Description:
 *      Return the number of characters in a wide character string (not
 *	the characters in the resultant mbs).
 * Input:
 *      ptr - wchar_t* : pointer to the wcs to count
 * Output:
 *      int : the number of characters found
 */
static int strlenWc ARGLIST((ptr)) GRA(wchar_t *, ptr)
{
  register wchar_t *p = ptr;
  register int x = 0;

  if (!ptr)
    return (0);

  while (*p++)
    x++;
  return (x);
}

/*
 * Function:
 *      bytesConv = doMbstowcs(wcs, mbs, n);
 * Description:
 *      Create a wcs string from an input mbs. 
 * Input:
 *	wcs - wchar_t* : pointer to result buffer of wcs
 *      mbs - char* : pointer to the source mbs
 *	n - size_t : the number of characters to convert
 * Output:
 *      bytesConv - size_t : number of bytes converted
 */
static size_t doMbstowcs ARGLIST((wcs, mbs, n)) ARG(wchar_t *, wcs) ARG(char *, mbs) GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
  int i;

  for (i = 0; i < n && mbs[i] != 0; ++i) {
    wcs[i] = mbs[i];
  }
  wcs[i++] = 0;
  return (i);
#else
  return (mbstowcs(wcs, mbs, n));
#endif
}

/*
 * Function:
 *      bytesConv = doWcstombs(wcs, mbs, n);
 * Description:
 *      Create a mbs string from an input wcs.
 * Input:
 *	wcs - wchar_t* : pointer to the source wcs
 *      mbs - char* : pointer to result mbs buffer 
 *	n - size_t : the number of characters to convert
 * Output:
 *      bytesConv - size_t : number of bytes converted
 */
static size_t doWcstombs ARGLIST((mbs, wcs, n)) ARG(char *, mbs) ARG(wchar_t *, wcs) GRA(size_t, n)
{
#ifndef SUPPORTS_WCHARS
  int i;

  for (i = 0; i < n && wcs[i] != 0; ++i) {
    mbs[i] = wcs[i];
  }
  mbs[i] = 0;
  return (i);
#else
  size_t retval;

  retval = wcstombs(mbs, wcs, (n * sizeof(wchar_t)));
  if (retval == (size_t) - 1)
    return (0);
  else
    return (retval);
#endif
}

/*
 * Function:
 *      copyWcsToMbs(mbs, wcs, len);
 * Description:
 *      Create a mbs string from an input wcs. This function allocates
 *	a buffer if necessary.
 * Input:
 *	mbs - char* : destination for the converted/copied output
 *	wcs - wchar_t* : pointer to wcs to copy/convert
 *	len - int : the number of wchar_t' to convert
 *	process_it - Boolean : True if processing of quoted charcters,
 *			False if blind.
 * Output:
 *      None
 */
static void copyWcsToMbs
ARGLIST((mbs, wcs, len, process_it))
ARG(char *, mbs) ARG(wchar_t *, wcs) ARG(int, len) GRA(Boolean, process_it)
{
  static wchar_t *tbuf = NULL;
  static int tbufSize = 0;

  int numCvt;
  int lenToConvert;
  wchar_t *fromP = wcs;
  wchar_t *x = &fromP[len];
  wchar_t *toP;
  wchar_t *commonWChars = CStrCommonWideCharsGet();
  wchar_t tmp;

  /*
   * Make sure there's room in the buffer
   */
  if (tbufSize < len) {
    tbuf = (wchar_t *) XtRealloc((char *)tbuf, (len + 1) * sizeof(wchar_t));
    tbufSize = len;
  }

  /*
   * Now copy and process
   */
  toP = tbuf;
  lenToConvert = 0;
  while (fromP < x) {
    /*
     * Check for quoted characters
     */
    if ((*fromP == commonWChars[WBackSlash]) && process_it) {
      fromP++;			/* Skip quote */
      if (fromP == x) {		/* Hanging quote? */
	*toP++ = commonWChars[WBackSlash];
	lenToConvert++;
	break;
      }
      tmp = *fromP++;
      if (tmp == commonWChars[WideN]) {
	*toP++ = commonWChars[WNewLine];
      } else if (tmp == commonWChars[WideT]) {
	*toP++ = commonWChars[WTab];
      } else if (tmp == commonWChars[WideR]) {
	*toP++ = commonWChars[WCarriageReturn];
      } else if (tmp == commonWChars[WideF]) {
	*toP++ = commonWChars[WFormFeed];
      } else if (tmp == commonWChars[WideV]) {
	*toP++ = commonWChars[WVerticalTab];
      } else if (tmp == commonWChars[WBackSlash]) {
	*toP++ = commonWChars[WBackSlash];
      } else {
	/*
	 * No special translation needed
	 */
	*toP++ = tmp;
      }
    } else {
      *toP++ = *fromP++;
    }
    lenToConvert++;
  }

  tmp = tbuf[lenToConvert];
  tbuf[lenToConvert] = 0;	/* (wchar_t) NULL; */
  numCvt = doWcstombs(mbs, tbuf, lenToConvert);
  tbuf[lenToConvert] = tmp;

  mbs[numCvt] = '\0';
}

/*
 * Function:
 *      status = dombtowc(wide, multi, size);
 * Description:
 *      Convert a multibyte character to a wide character.
 * Input:
 *      wide	- wchar_t *	: where to put the wide character
 *	multi	- char *	: the multibyte character to convert
 *	size	- size_t	: the number of characters to convert
 * Output:
 *      0	- if multi is a NULL pointer or points to a NULL character
 *	#bytes	- number of bytes in the multibyte character
 *	-1	- multi is an invalid multibyte character.
 *
 *	NOTE:  if wide is NULL, then this returns the number of bytes in
 *	       the multibyte character.
 */
static int dombtowc
ARGLIST((wide, multi, size)) ARG(wchar_t *, wide) ARG(char *, multi) GRA(size_t, size)
{
  int retVal = 0;

#ifndef SUPPORTS_WCHARS
  if ((multi == NULL) || (*multi == '\000')) {
    if (wide)
      wide[0] = '\0';
    return (0);
  }

  for (retVal = 0; retVal < size && multi[retVal] != '\000'; retVal++) {
    if (wide != NULL) {
      wide[retVal] = multi[retVal];
    }
  }
#else
  retVal = mbtowc(wide, multi, size);
#endif
  return (retVal);
}

/*
 * Function:
 *	ptr = getNextSepartor(str);
 * Description:
 *	Parse through a string looking for the next compound string
 *	field separator
 * Inputs:
 *	str - wchar_t* : the address of address of the string to parse
 * Outputs:
 *	ptr - wchar_t* : pointer to character, if found, points to end
 *			of string otherwise ('\0').
 */
static wchar_t *getNextSeparator ARGLIST((str)) GRA(wchar_t *, str)
{
  wchar_t *ptr = str;
  wchar_t *commonWChars = CStrCommonWideCharsGet();

  while (*ptr) {
    /*
     * Check for separator
     */
    if ((*ptr == commonWChars[WHash]) ||
	(*ptr == commonWChars[WQuote]) || (*ptr == commonWChars[WColon])) {
      return (ptr);
    } else if (*ptr == commonWChars[WBackSlash]) {
      ptr++;
      if (*ptr)
	ptr++;			/* Skip quoted character */
    } else {
      ptr++;
    }
  }
  return (ptr);
}

/*
 * Function:
 *	more =
 *        extractSegment(str, tagStart, tagLen, txtStart, txtLen, 
 *			pDir, pSep);
 * Description:
 *	Parse through a string version of a compound string and extract
 *	the first compound string segment from the string.
 * Inputs:
 *	str - char** : the address of address of the string to parse
 *	tagStart - char** : address to return pointer to tag start into 
 *	tagLen - int* : address where to return the tag length into
 *	txtStart - char** : address to return the text start into
 *	txtLen - int* : address where to return the text length
 *	pDir - int* : address to return the string direction into
 *	pSep - Boolean * : address to return the separtor into
 * Outputs:
 *	more - Boolean : True if more of the string to parse.
 *			False means done.
 */
static Boolean extractSegment
ARGLIST((str, tagStart, tagLen, txtStart, txtLen, pDir, pSep))
ARG(wchar_t **, str)
ARG(wchar_t **, tagStart)
ARG(size_t *, tagLen)
ARG(wchar_t **, txtStart) ARG(size_t *, txtLen) ARG(int *, pDir) GRA(Boolean *, pSep)
{
  wchar_t *start;
  wchar_t *text;
  int textL;
  Boolean tagSeen;
  wchar_t *tag;
  int tagL;
  Boolean modsSeen;
  Boolean sep;
  int dir;
  Boolean done;
  //int *lenUp;
  Boolean checkDir;
  wchar_t *commonWChars;
  wchar_t emptyStrWcs[1];

  /*
   * Initialize variables
   */
  text = NULL;
  textL = 0;
  tagSeen = False;
  tag = NULL;
  tagL = 0;
  modsSeen = False;
  dir = XmSTRING_DIRECTION_L_TO_R;
  sep = False;
  done = False;
  //lenUp = NULL;
  commonWChars = CStrCommonWideCharsGet();

  /*
   * Guard against nulls
   */
  if (!(start = *str)) {
    start = emptyStrWcs;
    emptyStrWcs[0] = commonWChars[WNull];
  }

  /*
   * If the first character of the string isn't a # or a ", then we
   * just have a regular old simple string. Do the same the thing for
   * the empty string.
   */
  if ((*start == '\0') || (start != getNextSeparator(start))) {
    text = start;
    if (!(textL = strlenWc(start))) {
      text = NULL;
    }
    start += textL;
  } else {
    done = False;
    while (!done) {
      if (*start == commonWChars[WHash]) {
	if (tagSeen) {
	  done = True;
	  break;
	} else {
	  tagSeen = True;
	  tag = ++start;
	  start = getNextSeparator(tag);
	  if ((tagL = start - tag) == 0) {
	    tag = NULL;		/* Null tag specified */
	  }
	}
      } else if (*start == commonWChars[WQuote]) {
	text = ++start;
	start = getNextSeparator(start);
	while (!((*start == commonWChars[WQuote]) || (*start == commonWChars[WNull]))) {
	  start = getNextSeparator(++start);
	}

	if ((textL = start - text) == 0) {
	  text = NULL;		/* Null text specified  */
	}
	/*
	 * if a quote, skip over it
	 */
	if (*start == commonWChars[WQuote]) {
	  start++;
	}
	done = True;
      } else if (*start == commonWChars[WColon]) {
	if (modsSeen) {
	  done = True;
	  break;
	}

	/*
	 * If the next character is a t or f, the we've got 
	 * a separator.
	 */
	modsSeen = True;
	checkDir = False;
	start++;
	if ((*start == commonWChars[WideT]) ||
	    (*start == commonWChars[WideUT]) || (*start == commonWChars[WideOne])) {
	  sep = True;
	  start++;
	  checkDir = True;
	} else if ((*start == commonWChars[WideF]) ||
		   (*start == commonWChars[WideUF]) || (*start == commonWChars[WideZero])) {
	  sep = False;
	  start++;
	  checkDir = True;
	} else if ((*start == commonWChars[WideR]) || (*start == commonWChars[WideUR])) {
	  start++;
	  dir = XmSTRING_DIRECTION_R_TO_L;
	} else if ((*start == commonWChars[WideL]) || (*start == commonWChars[WideUL])) {
	  start++;
	  dir = XmSTRING_DIRECTION_L_TO_R;
	}
	/*
	 * Look for direction if necessary. This requires a bit of
	 * look ahead.
	 */
	if (checkDir && (*start == commonWChars[WColon])) {
	  if ((*(start + 1) == commonWChars[WideL]) || (*(start + 1) == commonWChars[WideUL])) {
	    dir = XmSTRING_DIRECTION_L_TO_R;
	    start += 2;
	  } else if ((*(start + 1) == commonWChars[WideR]) ||
		     (*(start + 1) == commonWChars[WideUR])) {
	    dir = XmSTRING_DIRECTION_R_TO_L;
	    start += 2;
	  }
	}
      } else {
	/*
	 * A bad string format! We'll just skip the character.
	 */
	start++;
      }
    }
  }

  /*
   * Now fill in return values
   */
  if (*str)
    *str = start;
  if (tagStart)
    *tagStart = tag;
  if (tagLen)
    *tagLen = tagL;
  if (txtStart)
    *txtStart = text;
  if (txtLen)
    *txtLen = textL;
  if (pDir)
    *pDir = dir;
  if (pSep)
    *pSep = sep;

  return ((*start == commonWChars[WNull]) ? False : True);
}

/*
 * Function:
 *	xstr = StringToXmString(str);
 * Description:
 *	Parse a string into an XmString.
 * Inputs:
 *	str - char * : the string to parse
 * Outputs:
 *	xstr - XmString : the allocated return structure
 */
static XmString StringToXmString ARGLIST((str)) GRA(char *, str)
{
  static char *tagBuf = NULL;
  static size_t tagBufLen = 0;
  static char *textBuf = NULL;
  static size_t textBufLen = 0;

  wchar_t *ctx;
  wchar_t *tag;
  size_t tagLen;
  wchar_t *text;
  size_t textLen;
  Boolean sep;
  int dir;

  Boolean more;
  wchar_t *wcStr;
  int curDir;
  XmString xmStr;
  XmString s1;
  XmString s2;

  if (!str)
    return (NULL);

  /*
   * For expediencies sake, we'll overallocate this buffer so that
   * the wcs is guaranteed to fit (1 wc per byte in original string).
   */
  wcStr = (wchar_t *) XtMalloc((strlen(str) + 1) * sizeof(wchar_t));
  doMbstowcs(wcStr, str, strlen(str) + 1);

  /*
   * Create the beginning segment
   */
  curDir = XmSTRING_DIRECTION_L_TO_R;
  xmStr = XmStringDirectionCreate(curDir);

  /*
   * Convert the string.
   */
  more = True;
  ctx = wcStr;
  while (more) {
    more = extractSegment(&ctx, &tag, &tagLen, &text, &textLen, &dir, &sep);
    /*
     * Pick up a direction change
     */
    if (dir != curDir) {
      curDir = dir;
      s1 = XmStringDirectionCreate(curDir);
      s2 = xmStr;
      xmStr = XmStringConcat(s2, s1);
      XmStringFree(s1);
      XmStringFree(s2);

    }

    /*
     * Create the segment. Text and tag first.
     */
    if (textLen) {
      if (textBufLen <= (textLen * sizeof(wchar_t))) {
	textBufLen = (textLen + 1) * sizeof(wchar_t);
	textBuf = (char *)XtRealloc(textBuf, textBufLen);
      }
      copyWcsToMbs(textBuf, text, textLen, True);

      if (tagLen) {
	if (tagBufLen <= (tagLen * sizeof(wchar_t))) {
	  tagBufLen = (tagLen + 1) * sizeof(wchar_t);
	  tagBuf = (char *)XtRealloc(tagBuf, tagBufLen);
	}
	copyWcsToMbs(tagBuf, tag, tagLen, False);
      } else {
	if (!tagBuf) {
	  tagBufLen = strlen(XmSTRING_DEFAULT_CHARSET) + 1;
	  tagBuf = (char *)XtMalloc(tagBufLen);
	}
	strcpy(tagBuf, XmSTRING_DEFAULT_CHARSET);
      }

      s1 = XmStringCreate(textBuf, tagBuf);
      s2 = xmStr;
      xmStr = XmStringConcat(s2, s1);
      XmStringFree(s1);
      XmStringFree(s2);
    }

    /*
     * Add in the separators.
     */
    if (sep) {
      s1 = XmStringSeparatorCreate();
      s2 = xmStr;
      xmStr = XmStringConcat(s2, s1);
      XmStringFree(s1);
      XmStringFree(s2);
    }
  }

  /*
   * Free up memory and return
   */
  XtFree((char *)wcStr);
  return (xmStr);
}

/*
 * Function:
 *      nextCStr = getNextCStrDelim(str);
 * Description:
 *      Find the next unquoted , or \n in the string
 * Input:
 *	str - char * : the input string
 * Output:
 *      nextCStr - char* : pointer to the next delimiter. Returns NULL if no
 *			delimiter found.
 */
static char *getNextCStrDelim ARGLIST((str)) GRA(char *, str)
{
  char *comma = str;
  Boolean inQuotes = False;
  int len;

  if (!str)
    return (NULL);
  if (!*str)
    return (NULL);		/* At end */

#ifdef __CENTERLINE__
  mblen((char *)NULL, sizeof(wchar_t));
#else
  mblen(NULL, sizeof(wchar_t));
#endif
  while (*comma) {
    if ((len = mblen(comma, sizeof(wchar_t))) > 1) {
      comma += len;
      continue;
    }

    if (*comma == '\\') {
      comma++;			/* Over quote */
      comma += mblen(comma, sizeof(wchar_t));
      continue;
    }

    /*
     * See if we have a delimiter
     */
    if (!inQuotes) {
      if ((*comma == ',') || (*comma == '\012')) {
	return (comma);
      }
    }

    /*
     * Deal with quotes
     */
    if (*comma == '\"') {
      inQuotes = ~inQuotes;
    }

    comma++;
  }

  return (NULL);		/* None found */
}

/*
 * Function:
 *	cnt = getCStrCount(str);
 * Description:
 *      Get the count of cstrings in a compound string table ascii
 *	format.
 * Input:
 *      str - char * : string to parse
 * Output:
 *      cnt - int : the number of XmStrings found
 */
static int getCStrCount ARGLIST((str)) GRA(char *, str)
{
  int x = 1;
  char *newStr;

  if (!str)
    return (0);
  if (!*str)
    return (0);

  while ((newStr = getNextCStrDelim(str))) {
    x++;
    str = ++newStr;
  }
  return (x);
}

/*
 * Function:
 *      cwc = CStrCommonWideCharsGet();
 * Description:
 *      Return the array of common wide characters.
 * Input:
 *      None.
 * Output:
 *     	cwc - wchar_t * : this array should never be written to or FREEd.
 */
static wchar_t *CStrCommonWideCharsGet()
{
  static wchar_t *CommonWideChars = NULL;
  /*
   * If you add to this array, don't forget to change the enum in
   * the TYPEDEFS and DEFINES section above to correspond to this
   * array.
   */
  static char *characters[] = { "\000", "\t", "\n", "\r", "\f", "\v",
    "\\", "\"", "#", ":", "f", "l", "n", "r",
    "t", "v", "F", "L", "R", "T", "0", "1"
  };

  if (CommonWideChars == NULL) {
    int i;

    /*
     * Allocate and create the array.
     */
    CommonWideChars = (wchar_t *) XtMalloc(NUM_COMMON_WCHARS * sizeof(wchar_t));

    for (i = 0; i < NUM_COMMON_WCHARS; i++) {
      (void)dombtowc(&(CommonWideChars[i]), characters[i], 1);
    }
  }
  return (CommonWideChars);
}

/*
 * Function:
 *	CONVERTER CvtStringToXmString
 *           and
 *	XmStringCvtDestroy
 * Description:
 *	Convert a string to an XmString. This allows a string contained in
 *	resource file to contain multiple fonts. The syntax for the string
 *	is:
 *		::[#[font-tag]]"string"[#[font-tag]"string"] ...
 *
 *	note that the # can be escaped (\#).
 *
 * Input:
 * Output:
 *	Standard.
 */
static Boolean CvtStringToXmString
ARGLIST((d, args, num_args, fromVal, toVal, data))
ARG(Display *, d)
UARG(XrmValue *, args __attribute__ ((unused)))
ARG(Cardinal *, num_args __attribute__ ((unused))) ARG(XrmValue *, fromVal) ARG(XrmValue *, toVal) GRAU(XtPointer, data __attribute__ ((unused)))
{
  static XmString resStr;
  char *str;

  /*
   * This converter takes no parameters
   */
  if (*num_args != 0) {
    XtAppWarningMsg(XtDisplayToApplicationContext(d),
		    "cvtStringToXmString",
		    "wrongParameters",
		    "XtToolkitError",
		    "String to XmString converter needs no extra arguments",
		    (String *) NULL, (Cardinal *) NULL);
  }

  /*
   * See if this is a simple string
   */
  str = (char *)fromVal->addr;
  if (strncmp(str, "::", 2)) {
    resStr = XmStringCreateLtoR(fromVal->addr, XmSTRING_DEFAULT_CHARSET);
  } else {
    /*
     * Convert into internal format
     */
    resStr = StringToXmString(fromVal->addr + 2);	/* skip :: */
  }

  /*
   * Done, return result
   */
  if (toVal->addr == NULL) {
    toVal->addr = (XTPOINTER) & resStr;
    toVal->size = sizeof(XmString);
  } else if (toVal->size < sizeof(XmString)) {
    toVal->size = sizeof(XmString);
    XtDisplayStringConversionWarning(d, fromVal->addr, "XmString");
    XmStringFree(resStr);
    return (False);
  } else {
    *(XmString *) toVal->addr = resStr;
    toVal->size = sizeof(XmString);
  }
  return (True);
}

static void XmStringCvtDestroy
ARGLIST((app, to, data, args, num_args))
  UARG(XtAppContext, app __attribute__ ((unused)))
  ARG(XrmValue *, to) UARG(XtPointer, data __attribute__ ((unused)))
  UARG(XrmValue *, args __attribute__ ((unused))) GRAU(Cardinal *, num_args __attribute__ ((unused)))
{
  XmStringFree(*(XmString *) (to->addr));
}

/*
 * Function:
 *      CONVERTER CvtStringToXmStringTable
 *          and
 *      XmStringTableCvtDestroy
 *
 * Description:
 *	Convert a string to an XmString table. This allows a string contained in
 *	resource file to contain multiple fonts. The syntax for the string
 *	is:
 *	   compound_string = [#[font-tag]]"string"[#[font-tag]"string"] ...
 *	   compound_string_table = [compound_string][,compound_string] ...
 *
 *	note that the # can be escaped (\#).
 *
 * Input:
 * Output:
 *	Standard.
 */
static Boolean CvtStringToXmStringTable
ARGLIST((d, args, num_args, fromVal, toVal, data))
ARG(Display *, d)
ARG(XrmValue *, args)
ARG(Cardinal *, num_args) ARG(XrmValue *, fromVal) ARG(XrmValue *, toVal)
GRAU(XtPointer, data __attribute__ ((unused)))
{
  static XmString *CStrTable;
  XmString *tblPtr;
  char *str;
  char *tmpBuf;
  char *nextDelim;
  XrmValue fVal;
  XrmValue tVal;

  /*
   * This converter takes no parameters
   */
  if (*num_args != 0) {
    XtAppWarningMsg
	(XtDisplayToApplicationContext(d),
	 "cvtStringToXmStringTable",
	 "wrongParameters",
	 "XtToolkitError",
	 "String to XmStringTable converter needs no extra arguments",
	 (String *) NULL, (Cardinal *) NULL);
  }

  /*
   * Set str and make sure there's somethin' there
   */
  if (!(str = (char *)fromVal->addr)) {
    str = "";
  }

  /*
   * Allocate the XmStrings + 1 for NULL termination
   */
  CStrTable = (XmString *) XtMalloc((getCStrCount(str) + 1) * sizeof(XmString *));

  /*
   * Use the string converter for the strings
   */
  tmpBuf = (char *)XtMalloc(strlen(str) + 1);
  strcpy(tmpBuf, str);
  str = tmpBuf;

  /*
   * Create strings
   */
  tblPtr = CStrTable;
  if (*str) {
    while (str) {
      nextDelim = getNextCStrDelim(str);

      /*
       * Overwrite nextDelim
       */
      if (nextDelim) {
	*nextDelim = '\0';
	nextDelim++;
      }

      /*
       * Convert it
       */
      fVal.size = strlen(str) + 1;
      fVal.addr = str;
      tVal.size = sizeof(XTPOINTER);
      tVal.addr = (XTPOINTER) tblPtr;

      /*
       * Call converter ourselves since this is used to create
       * the strings in the table we create. We need to do this
       * since we don't have a widget to send to the XtConvertAndStore
       * function. Side effects are that we can never get these
       * compound strings cached and that no destructor function is
       * called when the strings leave existance, but we nuke 'em
       * in the XmStringTable destuctor.
       */
      CvtStringToXmString(d, args, num_args, &fVal, &tVal, NULL);
      tblPtr++;
      str = nextDelim;
    }
  }
  XtFree(tmpBuf);

  /*
   * Null terminate
   */
  *tblPtr = NULL;

  /*
   * Done, return result
   */
  if (toVal->addr == NULL) {
    toVal->addr = (XTPOINTER) & CStrTable;
    toVal->size = sizeof(XmString);
  } else if (toVal->size < sizeof(XmString *)) {
    toVal->size = sizeof(XmString *);
    XtDisplayStringConversionWarning(d, fromVal->addr, "XmStringTable");

    tblPtr = CStrTable;
    while (*tblPtr) {
      XmStringFree(*tblPtr);
    }
    XtFree((char *)CStrTable);
    return (False);
  } else {
    *(XmString **) toVal->addr = CStrTable;
    toVal->size = sizeof(XmString *);
  }
  return (True);
}

static void XmStringTableCvtDestroy
ARGLIST((app, to, data, args, num_args))
  UARG(XtAppContext, app __attribute__ ((unused)))
  ARG(XrmValue *, to) UARG(XtPointer, data __attribute__ ((unused)))
  UARG(XrmValue *, args __attribute__ ((unused))) GRAU(Cardinal *, num_args __attribute__ ((unused)))
{
  XmString *tblPtr = *(XmString **) (to->addr);

  while (*tblPtr) {
    XmStringFree(*tblPtr);
  }
  XtFree((char *)(*(XmString **) (to->addr)));
}

/*****************************************************************************
 *	GLOBAL CODE
 *****************************************************************************/

/*
 * Function:
 *      RegisterBxConverters(appContext);
 * Description:
 *      This globally available function installs all the converters necessary
 *	to run BuilderXcessory generated interfaces that use compound
 *	strings. This is necessary since Motif has not supplied very smart
 *	converters.
 * Input:
 *      appContext - XtAppContext : the application context
 * Output:
 *      None
 */
void RegisterBxConverters ARGLIST((appContext)) GRA(XtAppContext, appContext)
{
  XtAppSetTypeConverter(appContext, XmRString, XmRXmString,
			(XtTypeConverter) CvtStringToXmString,
			NULL, 0, XtCacheNone, XmStringCvtDestroy);

  XtAppSetTypeConverter(appContext, XmRString, XmRXmStringTable,
			(XtTypeConverter) CvtStringToXmStringTable,
			NULL, 0, XtCacheNone, XmStringTableCvtDestroy);
}

/*
 * Function:
 *      CONVERT(w, from_string, to_type, to_size, success);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      w - Widget : the widget to use for conversion
 *	from_string - char * : the string to convert from
 *	to_type - char * : the type to convert to
 *	to_size - int : the size of the conversion result
 *	success - Boolean* : Set to the result value of the conversion
 * Output:
 *      None
 */
#ifndef IGNORE_CONVERT
XtPointer CONVERT
ARGLIST((w, from_string, to_type, to_size, success))
ARG(Widget, w)
ARG(char *, from_string) ARG(char *, to_type) ARG(int, to_size __attribute__ ((unused))) GRA(Boolean *, success)
{
  XrmValue fromVal, toVal;	/* resource holders             */
  Boolean convResult;		/* return value                 */
  XtPointer val;		/* Pointer size return value    */

  to_size = 0;

  /*
   * We will assume that the conversion is going to fail and change this
   * value later if the conversion is a success.
   */
  *success = False;

  /*
   * Since we are converting from a string to some type we need to
   * set the fromVal structure up with the string information that
   * the caller passed in.
   */
  fromVal.size = strlen(from_string) + 1;
  fromVal.addr = from_string;

  /*
   * Since we are not sure what type and size of data we are going to
   * get back we will set this up so that the converter will point us
   * at a block of valid data.
   */
  toVal.size = 0;
  toVal.addr = NULL;

  /*
   * Now lets try to convert this data by calling this handy-dandy Xt
   * routine.
   */
  convResult = XtConvertAndStore(w, XmRString, &fromVal, to_type, &toVal);

  /*
   * Now we have two conditions here.  One the conversion was a success
   * and two the conversion failed.
   */
  if (!convResult) {
    /*
     * If this conversion failed that we can pretty much return right
     * here because there is nothing else we can do.
     */
    return ((XtPointer) NULL);
  }

  /*
   * If we get this far that means we did the conversion and all is
   * well.  Now we have to handle the special cases for type and
   * size constraints.
   */
  if (!strcmp(to_type, "String")) {
    /*
     * Since strings are handled different in Xt we have to deal with
     * the conversion from a string to a string.  When this happens the
     * toVal.size will hold the strlen of the string so generic
     * conversion code can't handle it.  It is possible for a string to
     * string conversion to happen so we do have to watch for it.
     */
    val = (XTPOINTER) toVal.addr;
  } else if (!strcmp(to_type, "Double")) {
    val = (XTPOINTER) ((double *)toVal.addr);
  } else if (!strcmp(to_type, "Float")) {
    val = (XTPOINTER) ((float *)toVal.addr);
  } else {
    /*
     * Here is the generic conversion return value handler.  This 
     * just does some size specific casting so that value that we
     * return is in the correct bytes of the XtPointer that we
     * return.  Here we check all sizes from 1 to 8 bytes.
     */
    union {
      char c;
      short s;
      int i;
      long l;
      XTPOINTER p;
    } uval;
    switch (toVal.size) {
    case 1:
      uval.c = *(char *)toVal.addr;
      break;
    case 2:
      uval.s = *(short *)toVal.addr;
      break;
    case 4:
      uval.i = *(int *)toVal.addr;
      break;
    case 8:
    default:
      uval.l = *(long *)toVal.addr;
      break;
    }
    val = uval.p;
  }

  /*
   * Well everything is done and the conversion was a success so lets
   * set the success flag to True.
   */
  *success = convResult;

  /*
   * Finally lets return the converted value.
   */
  /*SUPPRESS 80 */
  return (val);
}
#endif

/*
 * Function:
 *      MENU_POST(p, mw, ev, dispatch);
 * Description:
 *      A converter wrapper for convenience from BuilderXcessory.
 * Input:
 *      p - Widget : the widget to post
 *	mw - XtPointer : the menu widget
 *	ev - XEvent* : the event that caused the menu post
 *	dispatch - Boolean* : not used
 * Output:
 *      None
 */

#ifndef IGNORE_MENU_POST

void MENU_POST
ARGLIST((p, mw, ev, dispatch))
  UARG(Widget, p __attribute__ ((unused))) ARG(XtPointer, mw) ARG(XEvent *, ev) GRAU(Boolean *, dispatch __attribute__ ((unused)))
{
  Arg args[2];
  int argcnt;
  Cardinal button;
  Widget m = (Widget) mw;
  XButtonEvent *e = (XButtonEvent *) ev;

  argcnt = 0;
  XtSetArg(args[argcnt], XmNwhichButton, &button);
  argcnt++;
  XtGetValues(m, args, argcnt);
  if (e->button != button)
    return;
  XmMenuPosition(m, e);
  XtManageChild(m);
}
#endif

/*
 * Function:
 *      SET_BACKGROUND_COLOR(w, args, argcnt, bg_color);
 * Description:
 *      Sets the background color and shadows of a widget.
 * Input:
 *      w - The widget to set the background color on.
 *      args, argcnt - The argument list so far.
 *      bg_color - The new background color as a pixel.
 * Output:
 *      none
 *
 *  NOTES:  This assumes that args later in the argument list
 *          override those already in the list.  Therfore i f
 *          there are shadow colors later in the list they will win.
 *        
 *          There is no need to use this function when creating a widget
 *          only when doing a set values, shadow colors are automatically
 *          calculated at creation time.
 */

void SET_BACKGROUND_COLOR
ARGLIST((w, args, argcnt, bg_color))
  ARG(Widget, w __attribute__ ((unused))) ARG(ArgList, args) ARG(Cardinal *, argcnt) GRA(Pixel, bg_color)
{

#if ((XmVERSION == 1) && (XmREVISION > 0))
  int i;
  int topShadowLoc;
  int bottomShadowLoc;
  int selectLoc;
  int fgLoc;

  /*
   * Walk through the arglist to see if the user set the top or
   * bottom shadow colors.
   */
  selectLoc = topShadowLoc = bottomShadowLoc = UNSET;
  for (i = 0; i < *argcnt; i++) {
    if ((strcmp(args[i].name, XmNtopShadowColor) == 0) ||
	(strcmp(args[i].name, XmNtopShadowPixmap) == 0)) {
      topShadowLoc = i;
    } else if ((strcmp(args[i].name, XmNbottomShadowColor) == 0) ||
	       (strcmp(args[i].name, XmNbottomShadowPixmap) == 0)) {
      bottomShadowLoc = i;
    } else if (strcmp(args[i].name, XmNarmColor) == 0) {
      selectLoc = i;
    } else if (strcmp(args[i].name, XmNforeground) == 0) {
      fgLoc = i;
    }
  }

  /*
   * If either the top or bottom shadow are not set then we
   * need to use XmGetColors to get the shadow colors from the backgound
   * color and add those that are not already in the arglist to the
   * arglist.
   * 
   */
  if ((bottomShadowLoc == UNSET) ||
      (topShadowLoc == UNSET) || (selectLoc == UNSET) || (fgLoc == UNSET)) {
    Arg larg[1];
    Colormap cmap;
    Pixel topShadow;
    Pixel bottomShadow;
    Pixel select;
    Pixel fgColor;

    XtSetArg(larg[0], XmNcolormap, &cmap);
    XtGetValues(w, larg, 1);
    XmGetColors(XtScreen(w), cmap, bg_color, &fgColor, &topShadow, &bottomShadow, &select);

    if (topShadowLoc == UNSET) {
      XtSetArg(args[*argcnt], XmNtopShadowColor, topShadow);
      (*argcnt)++;
    }

    if (bottomShadowLoc == UNSET) {
      XtSetArg(args[*argcnt], XmNbottomShadowColor, bottomShadow);
      (*argcnt)++;
    }

    if (selectLoc == UNSET) {
      XtSetArg(args[*argcnt], XmNarmColor, select);
      (*argcnt)++;
    }

    if (fgLoc == UNSET) {
      XtSetArg(args[*argcnt], XmNforeground, fgColor);
      (*argcnt)++;
    }
  }
#endif

  XtSetArg(args[*argcnt], XmNbackground, bg_color);
  (*argcnt)++;
}

/*
 * Function:
 *	w = BxFindTopShell(start);
 * Description:
 *	Go up the hierarhcy until we find a shell widget.
 * Input:
 *      start - Widget : the widget to start with.
 * Output:
 *	w - Widget : the shell widget.
 */
#ifndef _BX_FIND_TOP_SHELL
#define _BX_FIND_TOP_SHELL

Widget BxFindTopShell ARGLIST((start)) GRA(Widget, start)
{
  Widget p;

  while ((p = XtParent(start))) {
    start = p;
  }
  return (start);
}
#endif				/* _BX_FIND_TOP_SHELL */

/*
 * Function:
 *	BxWidgetIdsFromNames(ref, cbName, stringList)
 * Description:
 *	Return an array of widget ids from a list of widget names.
 * Input:
 *	ref - Widget : reference widget.
 *	cbName - char* : callback name.
 *	stringList - char*: list of widget names.
 * Output:
 *	WidgetList : array of widget IDs.
 */

#ifndef _BX_WIDGETIDS_FROM_NAMES
#define _BX_WIDGETIDS_FROM_NAMES

WidgetList BxWidgetIdsFromNames
ARGLIST((ref, cbName, stringList)) ARG(Widget, ref) ARG(char, *cbName)GRA(char, *stringList)
{
  WidgetList wgtIds = NULL;
  int wgtCount = 0;
  Widget inst;
  Widget current;
  String tmp;
  String start;
  String widget;
  char *ptr;

  /*
   * For backward compatibility, remove [ and ] from the list.
   */
  tmp = start = XtNewString(stringList);
  if ((start = strchr(start, '[')) != NULL)
    start++;
  else
    start = tmp;

  while ((start && *start) && isspace(*start)) {
    start++;
  }
  ptr = strrchr(start, ']');
  if (ptr) {
    *ptr = '\0';
  }

  ptr = start + strlen(start) - 1;
  while (ptr && *ptr) {
    if (isspace(*ptr)) {
      ptr--;
    } else {
      ptr++;
      break;
    }
  }
  if (ptr && *ptr) {
    *ptr = '\0';
  }

  /*
   * start now points to the first character after the [.
   * the list is now either empty, one, or more widget
   * instance names.
   */
  start = strtok(start, ",");
  while (start) {
    while ((start && *start) && isspace(*start)) {
      start++;
    }
    ptr = start + strlen(start) - 1;
    while (ptr && *ptr) {
      if (isspace(*ptr)) {
	ptr--;
      } else {
	ptr++;
	break;
      }
    }
    if (ptr && *ptr) {
      *ptr = '\0';
    }

    /*
     * Form a string to use with XtNameToWidget().
     */
    widget = (char *)XtMalloc((strlen(start) + 2) * sizeof(char));
    sprintf(widget, "*%s", start);

    /*
     * Start at this level and continue up until the widget is found 
     * or until the top of the hierarchy is reached.
     */
    current = ref;
    while (current != NULL) {
      inst = XtNameToWidget(current, widget);
      if (inst != NULL) {
	wgtCount++;
	wgtIds = (WidgetList) XtRealloc((char *)wgtIds, wgtCount * sizeof(Widget));
	wgtIds[wgtCount - 1] = inst;
	break;
      }
      current = XtParent(current);
    }

    if (current == NULL) {
      printf("Callback Error (%s):\n\t\
Cannot find widget %s\n", cbName, widget);
    }
    XtFree(widget);
    start = strtok(NULL, ",");
  }

  /*
   * NULL terminate the list.
   */
  wgtIds = (WidgetList) XtRealloc((char *)wgtIds, (wgtCount + 1) * sizeof(Widget));
  wgtIds[wgtCount] = NULL;

  XtFree((char *)tmp);
  return (wgtIds);
}
#endif				/* _BX_WIDGETIDS_FROM_NAMES */

XtPointer SINGLE ARGLIST((val)) GRA(float, val)
{
  XtPointer pointer;

  pointer = (XtPointer) XtMalloc(sizeof(float));
  if (pointer != NULL)
    *((float *)pointer) = val;
  return (pointer);
}

XtPointer DOUBLE ARGLIST((val)) GRA(double, val)
{
  XtPointer pointer;

  pointer = (XtPointer) XtMalloc(sizeof(double));
  if (pointer != NULL)
    *((double *)pointer) = val;
  return (pointer);
}

/*      Function Name:	BxStoreWidgetId
 *
 *      Description:   	This functions expects an address of a variable
 *		       	in client data.  The size of the variable must be
 *                      large enough to hold a Widget ID.  BxStoreWidgetId
 *                      copies the Widget ID to the variable whose address
 *                      is passed in client data.
 *
 *      Arguments:      Widget		w: 	the activating widget.
 *			XtPointer	client:	the address of the widget var.
 *			XtPointer	call:	the call data (unused).
 */

/* ARGSUSED */
void BxStoreWidgetId(
#if NeedFunctionPrototypes
		     Widget w, XtPointer client, XtPointer call __attribute__ ((unused)))
#else
		      w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#endif
{
  Widget *widAddr = (Widget *) client;

  if (widAddr == NULL) {
    return;
  }
  *widAddr = w;
}
