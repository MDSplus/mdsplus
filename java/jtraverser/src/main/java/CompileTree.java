import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

public class CompileTree extends Thread
{
    MDSplus.Tree tree;
    String experiment;
    int shot;

    //originalNames and renamedNames keep info about nodes to be renamed
    Vector <String>renamedDevices = new Vector();
    Vector <String>  renamedFieldNids = new Vector();
    Vector <String>newNames = new Vector();
    Vector <String>unresolvedExprV = new Vector();
    Vector <MDSplus.TreeNode> unresolvedNidV = new Vector();
    Vector <MDSplus.TreeNode> subtreeNids = new Vector();

    public static void main(String args[])
    {
	String experiment;
	int shot = -1;
	if(args.length < 1)
	{

	    System.out.println("Usage: java CompileTree <experiment> [<shot>]");
	    System.exit(0);
	}
	experiment = args[0];

	if(args.length > 1)
	{
	    try {
	        shot = Integer.parseInt(args[1]);
	    }catch(Exception exc)
	    {
	        System.out.println("Error Parsing shot number");
	        System.exit(0);
	    }
	}
	(new CompileTree(experiment, shot)).start();
    }


    CompileTree(String experiment, int shot)
    {
	this.experiment = experiment;
	this.shot = shot;
    }

    public void run()
    {
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	Document document = null;
	try {
	    DocumentBuilder builder = factory.newDocumentBuilder();
	    document = builder.parse(experiment + ".xml");
	} catch (SAXParseException spe) {
	   // Error generated by the parser
	   System.out.println("\n** Parsing error"
	      + ", line " + spe.getLineNumber()
	      + ", uri " + spe.getSystemId());
	   System.out.println("   " + spe.getMessage() );

	   // Use the contained exception, if any
	   Exception  x = spe;
	   if (spe.getException() != null)
	       x = spe.getException();
	   x.printStackTrace();

	} catch (SAXException sxe) {
	   // Error generated during parsing)
	   Exception  x = sxe;
	   if (sxe.getException() != null)
	       x = sxe.getException();
	   x.printStackTrace();

	} catch (ParserConfigurationException pce) {
	    // Parser with specified options can't be built
	    pce.printStackTrace();

	} catch (Exception ioe) {
	   // I/O error
	   ioe.printStackTrace();
	}

        try {
            tree = new MDSplus.Tree(experiment, shot, "NEW");
        }catch(Exception exc)
        {
            System.out.println(exc);
            System.exit(0);
        }

	Element rootNode = document.getDocumentElement();
	NodeList nodes = rootNode.getChildNodes();
	for(int i = 0; i < nodes.getLength(); i++)
	{
	    org.w3c.dom.Node currNode = nodes.item(i);
	    if(currNode.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) //Only element nodes at this
	        recCompile((Element)currNode);
	}


	//handle renamed nodes
	for(int i = 0; i < newNames.size(); i++)
	{
	    String newName = newNames.elementAt(i);
	    String deviceName = renamedDevices.elementAt(i);
	    String offsetStr = renamedFieldNids.elementAt(i);
	    try {
	        int deviceOffset = Integer.parseInt(offsetStr);
	        MDSplus.TreeNode deviceNid = tree.getNode(new MDSplus.TreePath(deviceName));
	        MDSplus.TreeNode renamedNid = new MDSplus.TreeNode(deviceNid.getNid()+deviceOffset);
                renamedNid.setCtxTree(Tree.curr_experiment);
	        renamedNid.rename(newName);
	    }catch(Exception exc)
	    {
	        System.out.println("Error renaming node of " + deviceName + " to " + newName + " : " + exc);
	    }
	}

	for (int i = 0; i < unresolvedNidV.size(); i++) {
          if(unresolvedExprV.elementAt(i).trim().equals("<no-node>"))
              continue;
	  MDSplus.Data data = null;
	  try {

	  //System.out.println((String) unresolvedExprV.elementAt(i));
	    tree.setDefault((MDSplus.TreeNode) unresolvedNidV.elementAt(i));
 	    data = tree.tdiCompile(unresolvedExprV.elementAt(i));
  	  }
	  catch (Exception exc) {
	     System.out.println("Error parsing expression " + unresolvedExprV.elementAt(i) + " : " + exc);
	  }
	  try {
	    unresolvedNidV.elementAt(i).putData(data);
	  }
	  catch (Exception exc) {
	    System.out.println("Error writing data: " + exc);
	  }

	}

//Set subtrees (apparently this must be done at the end....
      for(int i = 0; i < subtreeNids.size(); i++)
	{
	    try {
	        subtreeNids.elementAt(i).setSubtree(true);
	    }
	    catch (Exception exc) {
	    System.out.println("Error setting subtree: " + exc);
	  }
      }




	try {
	    tree.write();
	    tree.close();
	}catch(Exception exc)
	{
	    System.out.println("Error closeing tree: " + exc);
	}
    }

    void recCompile(Element node)
    {
	String type = node.getNodeName();
	String name = node.getAttribute("NAME");
	String usageStr = node.getAttribute("USAGE");
	MDSplus.TreeNode nid = null;
	boolean success;

	//System.out.println(name);
	try {
	    MDSplus.TreeNode parentNid = tree.getDefault();
	    success = false;
	    if(type.equals("data"))
	    {
	        boolean isDeviceField = node.getNodeName().equals("field");
	        Text dataNode = (Text)node.getFirstChild();
	        if(dataNode != null)
	        {
	            String dataStr = dataNode.getData();

	            MDSplus.Data data = null;
	          /*  try {
		    System.out.println(dataStr);

	                data = Data.fromExpr(dataStr);
	            }catch(Exception exc)*/
	            {
	              unresolvedExprV.addElement(dataStr);
	              unresolvedNidV.addElement(tree.getDefault());
	             }
	            try {
	                nid = tree.getDefault();
	                if(isDeviceField)
	                {
	                    MDSplus.Data oldData;
	                    try {
	                        oldData = nid.getData();
	                    }catch(Exception exc) {oldData = null; }
	                    if(oldData == null || !dataStr.equals(oldData.toString()))
	                        nid.putData(data);
	                }
	                else
	                    nid.putData(data);
	            }catch(Exception exc)
	            {
	                System.out.println("Error writing data: " + exc);
	            }
	        }
	        return;
	    }

	    //First handle renamed nodes: they do not need to be created, but to be renamed
	    String originalDevice = node.getAttribute("DEVICE");
	    String deviceOffsetStr = node.getAttribute("OFFSET_NID");
	    if(originalDevice != null && deviceOffsetStr != null &&
	        !originalDevice.equals("") && !deviceOffsetStr.equals(""))
	    {
	        String newName;
	        try {
	            newName = parentNid.getFullPath();
	        }catch(Exception exc)
	        {
	            System.err.println("Error getting renamed path: " + exc);
	            return;
	        }
	        if(type.equals("node"))
	            newName += "." + name;
	        else
	            newName += ":" + name;
	        newNames.addElement(newName);
	        renamedDevices.addElement(originalDevice);
	        renamedFieldNids.addElement(deviceOffsetStr);
	        return; //No descedents for a renamed node
	    }

	    if(type.equals("node"))
	    {
	        try  {
//                    if(name.length() > 12) name = name.substring(0,12);
//                    nid = tree.addNode("."+name, NodeInfo.USAGE_STRUCTURE, 0);
	            nid = addNode("."+name, "STRUCTURE");
	            if(usageStr != null && usageStr.equals("SUBTREE"))
	                subtreeNids.addElement(nid);
	            tree.setDefault(nid);
	            success = true;
	        }catch(Exception exc)
	        {
	            System.out.println("Error adding member " + name + " : "+ exc);
	        }
	    }
	    if(type.equals("member"))
	    {
	        try {
//                    if(name.length() > 12) name = name.substring(0,12);
//                    nid = tree.addNode(":"+name, usage, 0);
	            nid = addNode(":"+name, usageStr);
	            tree.setDefault(nid);
	            success = true;
	        }catch(Exception exc)
	        {
	            System.out.println("Error adding member " + name + " : "+ exc);
	        }
	    }

	    if(type.equals("device"))
	    {
	        String model = node.getAttribute("MODEL");

	        try {
	            Thread.currentThread().sleep(100);

	            tree.addDevice(name.trim(), model);
	            tree.setDefault(nid = tree.getNode(name.trim()));
	            success = true;
	        }
	        catch(Exception exc){}
	    }

	    if(type.equals("field"))
	    {
	      try {
	        nid = tree.getNode(name);
	        tree.setDefault(nid);
	        success = true;
	      }catch(Exception exc)
	      {
	        System.out.println("WARNING: device field  " + name + " not found in model ");
	      }
	    }
	    if(success)
	    {
	        //tags
	        String tagsStr = node.getAttribute("TAGS");
	        if(tagsStr != null && tagsStr.length() > 0)
	        {
	            int i = 0;
	            StringTokenizer st = new StringTokenizer(tagsStr, ", ");
	            String [] tags = new String[st.countTokens()];
	            while(st.hasMoreTokens())
	                tags[i++] = st.nextToken();
	            try
	            {
                        for(int j = 0; j < tags.length; j++)
                            nid.addTag(tags[j]);
	            }catch(Exception exc)
	            {
	                System.out.println("Error adding tags " + tagsStr + " : " + exc);
	            }
	        }

	        //flags
	        String flagsStr = node.getAttribute("FLAGS");
	        if(flagsStr != null && flagsStr.length() > 0)
	        {
	            int flags = 0;
	            StringTokenizer st = new StringTokenizer(flagsStr, ", ");
	            while(st.hasMoreTokens())
	            {
	                String flag = st.nextToken();
	                if(flag.equals("WRITE_ONCE"))
	                    flags |= NodeInfo.WRITE_ONCE;
	                if(flag.equals("COMPRESSIBLE"))
	                    flags |= NodeInfo.COMPRESSIBLE;
	                if(flag.equals("COMPRESS_ON_PUT"))
	                    flags |= NodeInfo.COMPRESS_ON_PUT;
	                if(flag.equals("NO_WRITE_MODEL"))
	                    flags |= NodeInfo.NO_WRITE_MODEL;
	                if(flag.equals("NO_WRITE_SHOT"))
	                    flags |= NodeInfo.NO_WRITE_SHOT;
	                if(flag.equals("COMPRESS_SEGMENTS"))
	                    flags |= NodeInfo.COMPRESS_SEGMENTS;
	            }
	            try {
	               nid.setNciFlags(flags);
	            }catch(Exception exc)
	            {
	                System.out.println("Error setting flags to node " + name + " : " + exc);
	            }
	        }

	        //state
	        String stateStr = node.getAttribute("STATE");
	        if(stateStr != null && stateStr.length() > 0)
	        {
	            try {
	             if(stateStr.equals("ON"))
	                nid.setOn(true);
	            if(stateStr.equals("OFF"))
	                nid.setOn(false);
	            }catch(Exception exc)
	            {
	                //System.out.println("Error setting state of node " + name + " : " + exc);
	            }
	        }

	        //Descend
	        NodeList nodes = node.getChildNodes();
	        for(int i = 0; i < nodes.getLength(); i++)
	        {
	            org.w3c.dom.Node currNode = nodes.item(i);
	            if(currNode.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) //Only element nodes at this
	                recCompile((Element)currNode);
	        }
	    }
	    tree.setDefault(parentNid);
	}catch(Exception exc)
	{
	    System.out.println("Internal error in recCompile: " + exc);
	    exc.printStackTrace();
	}
    }

    MDSplus.TreeNode  addNode(String name, String usage) throws Exception
    {
	MDSplus.TreeNode prevNid = tree.getDefault();
	String currName = name.substring(1);
	String prevNode = "";
	while(currName.length() > 12)
	{
	      String shortName = currName.substring(0, 12);
	      currName = currName.substring(12);
	      try {
		tree.addNode(prevNode + "."+shortName, "STRUCTURE");
	      }catch(Exception exc){}
	      prevNode += "."+shortName;
	}
	return tree.addNode(prevNode+name.substring(0,1)+currName, usage);
    }
}

