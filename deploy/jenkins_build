#!/bin/bash
print_help() {
    cat - <<EOF
$0

    This script is used for testing and building MDSplus
releases from jenkins. Normally one jenkins job is used
to trigger the builds of many other jobs to either test
MDSplus or build releases on various computing platforms
using docker containers.

    The trigger job would use a command such as:

    $0 --trigger [--test] 
         [--valgrind comma-list-of-tests-or-"all"] 
         [--release] 
         [--keys directory] [--distdir directory]
         [--verbose]

    The --test and --valgrind options will tell the build
jobs to build MDSplus from sources and perform tests on
the compiled code. The --release option will tell the build
jobs to build release versions of MDSplus and put the
installers in a subdirectory of the directory specified with
the --distdir option. The --keys option is for specifying a
directory which has a .gnupg subdirectory containing signing
keys to use when making packages. If the --keys option is not
specified the packages will not be signed. After issuing this
command the trigger job should use the "Trigger/call builds
on other projects" jenkins plugin to trigger the platform
build jobs passing predefined parameters. If just doing
testing a SRCDIR parameter must be defined with a value
of $WORKSPACE. This tells the build job where to get the
source code and configuration parameters for its build
operations. If performing a release you must also pass the
GIT_BRANCH parameter.

     The build jobs would use a command such as:

     $0 --build docker-image

All the build options are passed from the trigger job using
the SRCDIR parameter which informs the build job where to find
 the source and options for the build.

EOF
}

parse_valgrind() {
    IFS=',' read -ra ARR <<< "$1"
    VGTESTS=""
    for i in "${ARR[@]}"; do
	VGTESTS="${i} ${VGTESTS}"
    done
    echo ${VGTESTS}
}

parse_cmd() {
    while [[ "$1" == -* ]] ; do
	case "$1" in
	    -h|--help)
		print_help
		exit 0;;
	    --build)
		OP="BUILD"
		DOCKER_IMAGE=$2
		shift 2;;
	    -s|--srcdir)
		SRCDIR=$2
		shift 2;;
	    --sanitize)
		SAN_TESTS=$2
		shift 2;;
#	    -b|--builddir)
#		BUILDDIR=$2
#		shift 2;;
	    --tag_release)
		OP="TAG_RELEASE"
		shift 1;;
	    --trigger)
		OP="TRIGGER"
		shift 1;;
	    --test)
		TESTS=yes
		shift 1;;
	    --valgrind)
		VG_TESTS=$(parse_valgrind $2)
		shift 2;;
	    --release)
		MAKE_RELEASE=yes
		shift 1;;
	    --keys)
		SIGN_KEYS=$2
		shift 2;;
	    -v|--verbose)
		VERBOSE=yes
		shift
		;;
	    --distdir)
		DISTDIR=$2
		shift 2;;
            --dist)
		DIST=$2
		shift 2;;
	    --workspace)
		WORKSPACE=$2
		shift 2;;
	    *)
		break
		;;
	esac
    done
    if [ $# -ne 0 ] ; then
	echo "Incorrect parameters. Use --help for usage instructions."
	exit 1
    fi
}

test_64 () {
    set -e
    ulimit -c unlimited
    set -xv
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    if [ -r ${WORKSPACE}/tests ]
    then
	MDSPLUS_DIR=${WORKSPACE}/tests/64/buildroot;
	MDS_PATH=${MDSPLUS_DIR}/tdi;
	mkdir -p ${MDSPLUS_DIR};
	pushd ${WORKSPACE}/tests/64;
	${SRCDIR}/configure  \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin64 \
	    --libdir=${MDSPLUS_DIR}/lib64 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --enable-debug --host=x86_64-linux;
	$MAKE
	$MAKE install
	set +e
	tests_valgrind64=0
	if [ ! -z "${VG_TESTS}" ]
	then
	    if [[ "${VG_TESTS}" == *"all"* ]]
	    then
		$MAKE -k tests-valgrind TEST_FORMAT=tap 2>&1;
	    else
		$MAKE -k tests-valgrind VALGRIND_TOOLS="${VG_TESTS}" 2>&1;
	    fi
	    tests_valgrind64=$?;
	fi
	$MAKE -k tests TEST_FORMAT=tap 2>&1;
	tests_64=$?;
	popd;
	test_64_san_address=0
	test_64_san_thread=0
	test_64_san_undefined=0
	if [ "$SAN_TESTS" != "" ]
	then
	    IFS=',' read -ra ARR <<< "$SAN_TESTS"
	    for test in "${ARR[@]}"; do
		MDSPLUS_DIR=${WORKSPACE}/tests/64-san-${test}/buildroot;
		MDS_PATH=${MDSPLUS_DIR}/tdi;
		mkdir -p ${MDSPLUS_DIR};
		pushd ${WORKSPACE}/tests/64-san-${test};
		${SRCDIR}/configure \
			 --prefix=${MDSPLUS_DIR} \
			 --exec_prefix=${MDSPLUS_DIR} \
			 --bindir=${MDSPLUS_DIR}/bin64 \
			 --libdir=${MDSPLUS_DIR}/lib64 \
			 --with-gsi=/usr:gcc64 \
			 --with-java_target=6 \
			 --with-java_bootclasspath=${SRCDIR}/rt.jar \
			 --enable-debug --host=x86_64-linux \
			 --enable-sanitize-${test}
		status=$?
		if [ "$status" == 111 ]; then
		    echo "Sanitizer ${test} not supported. Skipping."
		    break
		elif [ "$status" = 0 ]; then
		    $MAKE
		    $MAKE install
		    $MAKE -k tests TEST_FORMAT=log 2>&1;
		    let test_64_san_${test}=$?
		else
		    echo "configure returned status $?"
		    let test_64_san_${test}=$?
		fi
		popd
	    done
	fi;
	set -e;
    fi;
}

test_32() {
    set -e
    set -o verbose
    ulimit -c unlimited
#    if [ "$VERBOSE" = "yes" ]
#    then
#       set -o verbose
#    fi
    if [ -r ${WORKSPACE}/tests ]
    then
	MDSPLUS_DIR=${WORKSPACE}/tests/32/buildroot;
	MDS_PATH=${MDSPLUS_DIR}/tdi;
	mkdir -p ${MDSPLUS_DIR};
	pushd ${WORKSPACE}/tests/32;
	${SRCDIR}/configure \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin32 \
	    --libdir=${MDSPLUS_DIR}/lib32 \
	    --with-gsi=/usr:gcc32 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --enable-debug --host=i686-linux;
	$MAKE
	$MAKE install
	set +e;
	tests_valgrind32=0
	if [ ! -z "${VG_TESTS}" ]
	then
	    if [[ "${VG_TESTS}" == *"all"* ]]
	    then
		$MAKE -k tests-valgrind TEST_FORMAT=tap 2>&1;
	    else
		$MAKE -k tests-valgrind VALGRIND_TOOLS="${VG_TESTS}" 2>&1;
	    fi
	    tests_valgrind32=$?;
	fi
	$MAKE -k tests TEST_FORMAT=tap 2>&1;
	tests_32=$?;
	popd;
	test_32_san_address=0
	test_32_san_thread=0
	test_32_san_undefined=0
	if [ "$SAN_TESTS" != "" ]
	then
	    IFS=',' read -ra ARR <<< "$SAN_TESTS"
	    for test in "${ARR[@]}"; do
		if [ "$test" = "thread" ]; then
		    echo "No 32-bit support for sanitize=thread. Skipping."
		    break
		fi
		MDSPLUS_DIR=${WORKSPACE}/tests/32-san-${test}/buildroot;
		MDS_PATH=${MDSPLUS_DIR}/tdi;
		mkdir -p ${MDSPLUS_DIR};
		pushd ${WORKSPACE}/tests/32-san-${test};
		${SRCDIR}/configure \
			 --prefix=${MDSPLUS_DIR} \
			 --exec_prefix=${MDSPLUS_DIR} \
			 --bindir=${MDSPLUS_DIR}/bin32 \
			 --libdir=${MDSPLUS_DIR}/lib32 \
			 --with-gsi=/usr:gcc32 \
			 --with-java_target=6 \
			 --with-java_bootclasspath=${SRCDIR}/rt.jar \
			 --enable-debug --host=i686-linux \
			 --enable-sanitize-${test}
		status=$?
		if [ "$status" == 111 ]; then
		    echo "Sanitizer ${test} not supported. Skipping."
		    break
		elif [ "$status" = 0 ]; then
		    $MAKE
		    $MAKE install
		    $MAKE -k tests TEST_FORMAT=log 2>&1;
		    let test_32_san_${test}=$?
		else
		    echo "Configure returned a status 0f $?"
		    let test_32_san_${test}=$?
		fi
		popd
	    done
	fi;
	set -e;
    fi;
}

check_tests() {
    failed=0;
    if [ -z "$ARCH" -o "$ARCH" = "x86_64" ]
    then
	if [ "$tests_64" != "0" ]
	then
	    echo "64-bit tests failed!!!";
	    failed=1;
	fi;
	if [ "$tests_valgrind64" != "0" ]
	then
	    echo "64-bit valgrind tests failed!!!";
	    failed=1;
	fi;
	for test in address thread undefined; do
 	    eval "status=\$test_64_san_${test}"
	    if [ "$status" != "0" ]
            then
		echo "64-bit --enable-sanitize-${test} failed"
		failed=1;
	    fi
	done;
    fi;
    if [ -z "$ARCH" -o "$ARCH" = "i386" ]
    then
	if [ ! -z "$tests_32" -a "$tests_32" != "0" ]
	then
	    echo "32-bit tests failed!!!";
	    failed=1;
	fi;
	if [ "$tests_valgrind32" != "0" ]
	then
	    echo "32-bit valgrind tests failed!!!";
	    failed=1;
	fi;
	for test in address thread undefined; do
 	    eval "status=\$test_32_san_${test}"
	    if [ "$status" != "0" ]
            then
		echo "32-bit --enable-sanitize-${test} failed"
		failed=1;
	    fi
	done;
    fi
    if [ "$failed" = "1" ]
    then
	exit 1;
    fi;
}

build_64 () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    MDSPLUS_DIR=${WORKSPACE}/release/usr/local/mdsplus;
    mkdir -p ${MDSPLUS_DIR};
    mkdir -p ${WORKSPACE}/release/64;
    pushd ${WORKSPACE}/release/64;
    ${SRCDIR}/configure \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin64 \
	    --libdir=${MDSPLUS_DIR}/lib64 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --host=x86_64-linux;
    $MAKE
    $MAKE install
    popd;
}

build_32 () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    MDSPLUS_DIR=${WORKSPACE}/release/usr/local/mdsplus;
    mkdir -p ${MDSPLUS_DIR};
    mkdir -p ${WORKSPACE}/release/32;
    pushd ${WORKSPACE}/release/32;
    ${SRCDIR}/configure  \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin32 \
	    --libdir=${MDSPLUS_DIR}/lib32 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --host=i686-linux;
    $MAKE
    $MAKE install
    popd ;
}

build_rpms () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    if [ "${DISTDIR}" != "" -a -r ${DISTDIR} ]
    then
        export DISTDIR=${DISTDIR}/${DIST}
	export BUILDROOT=${WORKSPACE}/release
	echo "Building rpms";
	mkdir -p ${WORKSPACE}/release/etc/yum.repos.d;
	mkdir -p ${WORKSPACE}/release/etc/pki/rpm-gpg/;
	export INSTALLER_DIR=${DISTDIR};
	mkdir -p ${INSTALLER_DIR}/BUILD ${INSTALLER_DIR}/BUILDROOT ${INSTALLER_DIR}/SPECS ${INSTALLER_DIR}/RPMS ${INSTALLER_DIR}/SRPMS;
	cp ${SRCDIR}/deploy/RPM-GPG-KEY-MDSplus ${WORKSPACE}/release/etc/pki/rpm-gpg/;
	cat - > ${WORKSPACE}/release/etc/yum.repos.d/mdsplus${BNAME}.repo <<EOF
[MDSplus${BNAME}]
name=MDSplus${BNAME}
baseurl=http://www.mdsplus.org/dist/${DIST}/${BRANCH}/RPMS
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-MDSplus
metadata_expire=300
EOF
	pushd ${SRCDIR}
	${SRCDIR}/deploy/build_rpms_mdsplus;
	popd
    fi;
}

build_eggs() {
    if [ "${DISTDIR}" != "" -a -r ${DISTDIR} ]
    then
	export BUILDROOT=${WORKSPACE}/release;
	export EGGS_DIR=${DISTDIR}/EGGS;
	mkdir -p ${EGGS_DIR}
	${SRCDIR}/deploy/build_eggs;
    fi;
}

build_debs() {
    echo "Building debian packages"
    mkdir -p /tmp/repo/conf
    mkdir -p /tmp/repo/db
    mkdir -p /tmp/repo/dists
    mkdir -p /tmp/repo/pool
    mkdir -p /tmp/${BNAME}/DEBS/amd64
    mkdir -p /tmp/${BNAME}/DEBS/i386
    mkdir -p /tmp/${BNAME}/DEBS/noarch
    cat - <<EOF > /tmp/repo/conf/distributions
Origin: MDSplus Development Team
Label: MDSplus
Codename: MDSplus
Version: ${MAJOR}.${MINOR}.${RELEASE}
Architectures: i386 amd64 source
Components: alpha stable local
Description: MDSplus packages
EOF
    if [ -d /root/.gnupg ]
    then 
      echo "SignWith: MDSplus" >> /tmp/repo/conf/distributions
    fi
    build_debs_mdsplus
}

set -e
set -xv
if [ -f /.dockerinit ]
then
    source build.conf
    MAKE=${MAKE:="env LANG=en_US.UTF-8 make"};
    # note: the TRIGGER ${WORKSPACE} is /mdsplus/source in jenkins current configuration
    source /mdsplus/source/jenkins_build.conf
    if [ -r ${WORKSPACE}/release ]
    then
	DIST_TAG_FILE=${DISTDIR}/${DIST}/${BRANCH}/mdsplus-${BRANCH}-${MAJOR}.${MINOR}-${RELEASE}
	export MDSPLUS_VERSION=${MAJOR}.${MINOR}.${RELEASE}
    fi
    case ${DIST_TYPE} in
	redhat)
	    if [ "${TESTS}" = "yes" ]
	    then
		test_64;
		test_32;
		check_tests;
	    fi
            if [ -r ${WORKSPACE}/release ]
            then
              RELEASE_DATE="$(date +"%B %e, %Y")"
	      build_64;
	      build_32;
	      build_rpms;
	      build_eggs;
            fi;;
	debian)
	    if [ "${TESTS}" = "yes" ]
	    then
		if [ "$ARCH" = "i386" ]
		then
		    test_32;
		else
		    test_64;
		fi
		check_tests;
	    fi
	    if [ -r ${WORKSPACE}/release ]
	    then
		if [ "$ARCH" = "i386" ]
		then
		    build_32;
		else
		    build_64;
		fi
		if [ "$LAST_IMAGE" = "yes" ];then
		    BUILDROOT=${WORKSPACE}/release;
		    build_debs;
		fi;
		build_eggs;
	    fi;;
	*)
	    echo Unknown DIST_TYPE: ${DIST_TYPE}
	    exit 1;;
    esac
    if [ -r /mdsplus/release ]
    then
	echo ${GIT_COMMIT} > $DIST_TAG_FILE
    fi
else
    parse_cmd $@
    case "$OP" in
	BUILD)
	    if [ -z "$WORKSPACE" ]
	    then
		WORKSPACE=$(pwd)
	    fi
	    if [ -z "$SRCDIR" ]
	    then
		echo "Source directory not specified"
		print_help
		exit 1;
	    fi
	    source ${SRCDIR}/jenkins_build.conf
	    if [ "$MAKE_RELEASE" = "yes" ]
	    then
		if [ -r ${WORKSPACE}/release ]
		then
		    DIST_TAG_FILE=${DISTDIR}/${DIST}/${BRANCH}/mdsplus-${BRANCH}-${MAJOR}.${MINOR}-${RELEASE}
		    if ( test -r $DIST_TAG_FILE &&
			 test "$(cat $DIST_TAG_FILE)" = "${GIT_COMMIT}" )
		    then
			echo "This release is already complete. Nothing else to do."
			exit 0
		    fi
		fi
		mkdir -p ${WORKSPACE}/release
		if [ -z "${DISTDIR}" ]
		then
		    echo "Distribution directory not specified"
		    print_help
		    exit 1;
		fi
		installer_volume="-v ${DISTDIR}:${DISTDIR}"
	    else
		rm -Rf ${WORKSPACE}/release
	    fi
	    if [ -z "$DOCKER_IMAGE" ]
	    then
		echo "Docker image not specified"
		print_help
		exit 1;
	    fi
	    IFS=',' read -ra DI_ARR <<< "$DOCKER_IMAGE"
	    images=0
            for DOCKER_IMAGE in "${DI_ARR[@]}"; do
		let images=images+1
		if [ $images -eq ${#DI_ARR[@]} ]; then
		    LAST_IMAGE=yes;
		else
		    LAST_IMAGE=no;
		fi;
		docker pull ${DOCKER_IMAGE}
		if [ "$TESTS" = "yes" -o "$VG_TESTS" != "" ]
		then
		    mkdir -p ${WORKSPACE}/tests
		else
		    rm -Rf ${WORKSPACE}/tests
		fi;
		if [ ! -z "$SIGN_KEYS" ]
		then
		    signkeys="-v ${SIGN_KEYS}/.gnupg:/root/.gnupg"
		fi
		docker run --name="${JOB_NAME}${BUILD_NUMBER}" \
		       --pid=host \
		       -t \
                       -u $(id -u):$(id -g) \
		       -v ${SRCDIR}:${SRCDIR} \
		       -v ${SRCDIR}:/mdsplus/source \
		       -v ${WORKSPACE}:${WORKSPACE} \
		       ${installer_volume} \
		       -e "WORKSPACE=${WORKSPACE}" \
		       -e "SRCDIR=${SRCDIR}" \
		       -e "LAST_IMAGE=${LAST_IMAGE}" \
		       ${sign_keys} \
		       ${DOCKER_IMAGE};
		docker rm "${JOB_NAME}${BUILD_NUMBER}";
	    done;;
	TRIGGER)
	    if [ "$MAKE_RELEASE" = "yes" ]
	    then
		BRANCH=${GIT_BRANCH:7};
		RELEASE_TAG=$(git tag | grep ${BRANCH}_release | sort -V | awk '{line=$0} END{print line}');
		MAJOR=$(echo $RELEASE_TAG | cut -f2 -d-);
		MINOR=$(echo $RELEASE_TAG | cut -f3 -d-);
		RELEASE=$(echo $RELEASE_TAG | cut -f4 -d-);
		if [ "$BRANCH" = "stable" ]
		then
		    BNAME=""
		else
		    BNAME="-${BRANCH}"
		fi
		if [ "$(git rev-list -n 1 $RELEASE_TAG)" != "${GIT_COMMIT}" ]
		then
		    let RELEASE=$RELEASE+1;
		    RELEASE_TAG=${BRANCH}_release-${MAJOR}-${MINOR}-${RELEASE};
		    git log --decorate=full > ChangeLog;
		fi;
		if [ ! -z "$SIGN_KEYS" ]
		then
		   signkeys="export SIGN_KEYS=$SIGN_KEYS"
		fi;
	    fi
	    cat - <<EOF > ${WORKSPACE}/jenkins_build.conf
export MAKE_RELEASE=$MAKE_RELEASE
export TESTS=$TESTS
export VG_TESTS="$VG_TESTS"
export SAN_TESTS="$SAN_TESTS"
export BRANCH=${BRANCH}
export BNAME=${BNAME}
export RELEASE_TAG=${RELEASE_TAG}
export MAJOR=${MAJOR}
export MINOR=${MINOR}
export RELEASE=${RELEASE}
export VERBOSE=${VERBOSE}
export DISTDIR=${DISTDIR}
export GIT_COMMIT=${GIT_COMMIT}
EOF
	    ;;
	TAG_RELEASE)
	    set -e
            set -o verbose
	    if ( test -r ${WORKSPACE}/jenkins_build.conf )
            then
		source ${WORKSPACE}/jenkins_build.conf
	    fi
	    if ( test "${RELEASE_TAG}" != "" )
	    then
		comment=$(echo "New release of ${BRANCH} branch of MDSplus." \
		               "Version mdsplus${BNAME}-${MAJOR}-${MINOR}-${RELEASE}");
		git tag -f -a -m  "${comment}" ${RELEASE_TAG};
		git push --follow-tags origin ${BRANCH};
	    else
		cat <<EOF
Invalid command option. tag_release is only avaliable after 
a valid $0 trigger --release has been executed.
EOF
		exit 1;
	    fi;;
	*) echo "Unknown option";
	   exit 1;
	   ;;
    esac
fi
