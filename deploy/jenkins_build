#!/bin/bash
print_help() {
    cat - <<EOF
$0

    This script is used for testing and building MDSplus
releases from jenkins. Normally one jenkins job is used
to trigger the builds of many other jobs to either test
MDSplus or build releases on various computing platforms
using docker containers.

    The trigger job would use a command such as:

    $0 --trigger [--test] 
         [--valgrind comma-list-of-tests-or-"all"] 
         [--release] 
         [--keys directory] [--distdir directory]
         [--verbose]

    The --test and --valgrind options will tell the build
jobs to build MDSplus from sources and perform tests on
the compiled code. The --release option will tell the build
jobs to build release versions of MDSplus and put the
installers in a subdirectory of the directory specified with
the --distdir option. The --keys option is for specifying a
directory which has a .gnupg subdirectory containing signing
keys to use when making packages. If the --keys option is not
specified the packages will not be signed. After issuing this
command the trigger job should use the "Trigger/call builds
on other projects" jenkins plugin to trigger the platform
build jobs passing predefined parameters. If just doing
testing a SRCDIR parameter must be defined with a value
of $WORKSPACE. This tells the build job where to get the
source code and configuration parameters for its build
operations. If performing a release you must also pass the
GIT_BRANCH parameter.

     The build jobs would use a command such as:

     $0 --build docker-image

All the build options are passed from the trigger job using
the SRCDIR parameter which informs the build job where to find
 the source and options for the build.

EOF
}

parse_valgrind() {
    IFS=',' read -ra ARR <<< "$1"
    VGTESTS=""
    for i in "${ARR[@]}"; do
	VGTESTS="${i} ${VGTESTS}"
    done
    echo ${VGTESTS}
}

parse_cmd() {
    while [[ "$1" == -* ]] ; do
	case "$1" in
	    -h|--help)
		print_help
		exit 0;;
	    --build)
		OP="BUILD"
		DOCKER_IMAGE=$2
		shift 2;;
	    -s|--srcdir)
		SRCDIR=$2
		shift 2;;
	    --sanitize)
		SAN_TESTS=$2
		shift 2;;
	    --tag_release)
		OP="TAG_RELEASE"
		shift 1;;
	    --upload_to_pypi)
		OP="UPLOAD_TO_PYPI"
		shift 1;;
	    --trigger)
		OP="TRIGGER"
		shift 1;;
	    --test)
		TESTS=yes
		shift 1;;
	    --valgrind)
		VG_TESTS=$(parse_valgrind $2)
		shift 2;;
	    --release)
		MAKE_RELEASE=yes
		shift 1;;
	    --publish)
		PUBLISH_RELEASE=yes
		shift 1;;
	    --keys)
		SIGN_KEYS=$2
		shift 2;;
	    -v|--verbose)
		VERBOSE=yes
		shift
		;;
	    --distdir)
		DISTDIR=$2
		shift 2;;
            --dist)
		DIST=$2
		shift 2;;
	    --workspace)
		WORKSPACE=$2
		shift 2;;
	    *)
		break
		;;
	esac
    done
    if [ $# -ne 0 ] ; then
	echo "Incorrect parameters. Use --help for usage instructions."
	exit 1
    fi
}

test_64 () {
    set -e
    set -xv
    if [ -r ${WORKSPACE}/tests ]
    then
	MDSPLUS_DIR=${WORKSPACE}/tests/64/buildroot;
	MDS_PATH=${MDSPLUS_DIR}/tdi;
	mkdir -p ${MDSPLUS_DIR};
	pushd ${WORKSPACE}/tests/64;
	${SRCDIR}/configure  \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin64 \
	    --libdir=${MDSPLUS_DIR}/lib64 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --enable-debug --host=x86_64-linux;
	$MAKE
	$MAKE install
	set +e
	tests_valgrind64=0
	if [ ! -z "${VG_TESTS}" ]
	then
	    if [[ "${VG_TESTS}" == *"all"* ]]
	    then
		$MAKE -k tests-valgrind TEST_FORMAT=tap 2>&1;
	    else
		$MAKE -k tests-valgrind VALGRIND_TOOLS="${VG_TESTS}" 2>&1;
	    fi
	    tests_valgrind64=$?;
	fi
	$MAKE -k tests TEST_FORMAT=tap 2>&1;
	tests_64=$?;
	popd;
	test_64_san_address=0
	test_64_san_thread=0
	test_64_san_undefined=0
	if [ "$SAN_TESTS" != "" ]
	then
	    IFS=',' read -ra ARR <<< "$SAN_TESTS"
	    for test in "${ARR[@]}"; do
		MDSPLUS_DIR=${WORKSPACE}/tests/64-san-${test}/buildroot;
		MDS_PATH=${MDSPLUS_DIR}/tdi;
		mkdir -p ${MDSPLUS_DIR};
		pushd ${WORKSPACE}/tests/64-san-${test};
		${SRCDIR}/configure \
			 --prefix=${MDSPLUS_DIR} \
			 --exec_prefix=${MDSPLUS_DIR} \
			 --bindir=${MDSPLUS_DIR}/bin64 \
			 --libdir=${MDSPLUS_DIR}/lib64 \
			 --with-gsi=/usr:gcc64 \
			 --with-java_target=6 \
			 --with-java_bootclasspath=${SRCDIR}/rt.jar \
			 --enable-debug --host=x86_64-linux \
			 --enable-sanitize=${test}
		status=$?
		if [ "$status" == 111 ]; then
		    echo "Sanitizer ${test} not supported. Skipping."
		    break
		elif [ "$status" = 0 ]; then
		    $MAKE
		    $MAKE install
		    $MAKE -k tests TEST_FORMAT=tap 2>&1;
		    let test_64_san_${test}=$?
		else
		    echo "configure returned status $?"
		    let test_64_san_${test}=$?
		fi
		popd
	    done
	fi;
	set -e;
    fi;
}

test_32() {
    set -e
    set -o verbose
    ulimit -c unlimited
#    if [ "$VERBOSE" = "yes" ]
#    then
#       set -o verbose
#    fi
    if [ -r ${WORKSPACE}/tests ]
    then
	MDSPLUS_DIR=${WORKSPACE}/tests/32/buildroot;
	MDS_PATH=${MDSPLUS_DIR}/tdi;
	mkdir -p ${MDSPLUS_DIR};
	pushd ${WORKSPACE}/tests/32;
	${SRCDIR}/configure \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin32 \
	    --libdir=${MDSPLUS_DIR}/lib32 \
	    --with-gsi=/usr:gcc32 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --enable-debug --host=i686-linux;
	$MAKE
	$MAKE install
	set +e;
	tests_valgrind32=0
	if [ ! -z "${VG_TESTS}" ]
	then
	    if [[ "${VG_TESTS}" == *"all"* ]]
	    then
		$MAKE -k tests-valgrind TEST_FORMAT=tap 2>&1;
	    else
		$MAKE -k tests-valgrind VALGRIND_TOOLS="${VG_TESTS}" 2>&1;
	    fi
	    tests_valgrind32=$?;
	fi
	$MAKE -k tests TEST_FORMAT=tap 2>&1;
	tests_32=$?;
	popd;
	test_32_san_address=0
	test_32_san_thread=0
	test_32_san_undefined=0
	if [ "$SAN_TESTS" != "" ]
	then
	    IFS=',' read -ra ARR <<< "$SAN_TESTS"
	    for test in "${ARR[@]}"; do
		if [ "$test" = "thread" ]; then
		    echo "No 32-bit support for sanitize=thread. Skipping."
		    break
		fi
		MDSPLUS_DIR=${WORKSPACE}/tests/32-san-${test}/buildroot;
		MDS_PATH=${MDSPLUS_DIR}/tdi;
		mkdir -p ${MDSPLUS_DIR};
		pushd ${WORKSPACE}/tests/32-san-${test};
		${SRCDIR}/configure \
			 --prefix=${MDSPLUS_DIR} \
			 --exec_prefix=${MDSPLUS_DIR} \
			 --bindir=${MDSPLUS_DIR}/bin32 \
			 --libdir=${MDSPLUS_DIR}/lib32 \
			 --with-gsi=/usr:gcc32 \
			 --with-java_target=6 \
			 --with-java_bootclasspath=${SRCDIR}/rt.jar \
			 --enable-debug --host=i686-linux \
			 --enable-sanitize=${test}
		status=$?
		if [ "$status" == 111 ]; then
		    echo "Sanitizer ${test} not supported. Skipping."
		    break
		elif [ "$status" = 0 ]; then
		    $MAKE
		    $MAKE install
		    $MAKE -k tests TEST_FORMAT=log 2>&1;
		    let test_32_san_${test}=$?
		else
		    echo "Configure returned a status 0f $?"
		    let test_32_san_${test}=$?
		fi
		popd
	    done
	fi;
	set -e;
    fi;
}

check_tests() {
    failed=0;
    if [ -z "$ARCH" -o "$ARCH" = "x86_64" -o "$ARCH" = "amd64" ]
    then
	if [ "$tests_64" != "0" ]
	then
	    echo "64-bit tests failed!!!";
	    failed=1;
	fi;
	if [ "$tests_valgrind64" != "0" ]
	then
	    echo "64-bit valgrind tests failed!!!";
	    failed=1;
	fi;
	for test in address thread undefined; do
 	    eval "status=\$test_64_san_${test}"
	    if [ "$status" != "0" ]
            then
		echo "64-bit --enable-sanitize=${test} failed"
		failed=1;
	    fi
	done;
    fi;
    if [ -z "$ARCH" -o "$ARCH" = "i386" -o "$ARCH" = "i686" -o "$ARCH" = "armhf" ]
    then
	if [ ! -z "$tests_32" -a "$tests_32" != "0" ]
	then
	    echo "32-bit tests failed!!!";
	    failed=1;
	fi;
	if [ "$tests_valgrind32" != "0" ]
	then
	    echo "32-bit valgrind tests failed!!!";
	    failed=1;
	fi;
	for test in address thread undefined; do
 	    eval "status=\$test_32_san_${test}"
	    if [ "$status" != "0" ]
            then
		echo "32-bit --enable-sanitize=${test} failed"
		failed=1;
	    fi
	done;
    fi
    if [ "$failed" = "1" ]
    then
	exit 1;
    fi;
}

build_64 () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    MDSPLUS_DIR=${WORKSPACE}/release/usr/local/mdsplus;
    mkdir -p ${MDSPLUS_DIR};
    mkdir -p ${WORKSPACE}/release/64;
    pushd ${WORKSPACE}/release/64;
    ${SRCDIR}/configure \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin64 \
	    --libdir=${MDSPLUS_DIR}/lib64 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --host=x86_64-linux;
    $MAKE
    $MAKE install
    popd;
}

build_32 () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    MDSPLUS_DIR=${WORKSPACE}/release/usr/local/mdsplus;
    mkdir -p ${MDSPLUS_DIR};
    mkdir -p ${WORKSPACE}/release/32;
    pushd ${WORKSPACE}/release/32;
    ${SRCDIR}/configure  \
	    --prefix=${MDSPLUS_DIR} \
	    --exec_prefix=${MDSPLUS_DIR} \
	    --bindir=${MDSPLUS_DIR}/bin32 \
	    --libdir=${MDSPLUS_DIR}/lib32 \
	    --with-gsi=/usr:gcc64 \
	    --with-java_target=6 \
	    --with-java_bootclasspath=${SRCDIR}/rt.jar \
	    --host=i686-linux;
    $MAKE
    $MAKE install
    popd ;
}

build_rpms () {
    set -e
    set -o verbose
#    if [ "$VERBOSE" = "yes" ]
#    then
#	set -o verbose
#    fi
    if [ "${DISTDIR}" != "" -a -r ${DISTDIR} ]
    then
        export INSTALLER_DIR=${DISTDIR}/${DIST}/${BRANCH}
	export BUILDROOT=${WORKSPACE}/release
	echo "Building rpms";
	mkdir -p ${WORKSPACE}/release/etc/yum.repos.d;
	mkdir -p ${WORKSPACE}/release/etc/pki/rpm-gpg/;
	mkdir -p ${INSTALLER_DIR}/RPMS;
	cp ${SRCDIR}/deploy/RPM-GPG-KEY-MDSplus ${WORKSPACE}/release/etc/pki/rpm-gpg/;
	cat - > ${WORKSPACE}/release/etc/yum.repos.d/mdsplus${BNAME}.repo <<EOF
[MDSplus${BNAME}]
name=MDSplus${BNAME}
baseurl=http://www.mdsplus.org/dist/${DIST}/${BRANCH}/RPMS
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-MDSplus
metadata_expire=300
EOF
	pushd ${SRCDIR}
	${SRCDIR}/deploy/build_rpms_mdsplus;
	popd
    fi;
}

build_rpm_repo() {
    export INSTALLER_DIR=${DISTDIR}/${DIST}/${BRANCH}
    createrepo -q ${INSTALLER_DIR}/RPMS
}

build_debs() {
    echo "Building debian packages"
    if [ "${DISTDIR}" != "" -a -r ${DISTDIR} ]
    then
        export INSTALLER_DIR=${DISTDIR}/${DIST}
	export BUILDROOT=${WORKSPACE}/release
	case "${ARCH}" in
	    amd64) BITS=64;;
	    i386)  BITS=32;;
	    armhf) BITS=32;;
	esac
	ln -s ${WORKSPACE}/release/bin${bits} ${WORKSPACE}/release/bin
	ln -s ${WORKSPACE}/release/lib${bits} ${WORKSPACE}/release/lib;
	mkdir -p ${INSTALLER_DIR}/${BRANCH}/DEBS/${ARCH}
	mkdir -p ${INSTALLER_DIR}/${BRANCH}/DEBS/noarch
	${SRCDIR}/deploy/build_debs_mdsplus
	rm -f ${WORKSPACE}/release/bin
	rm -f ${WORKSPACE}/release/lib
    fi
}

build_deb_repo() {
    set -e
    echo "Building debian repository"
    INSTALLER_DIR=${DISTDIR}/${DIST}
    if [ "$ARCH" = "armhf" ]
    then
	arches=armhf
    else
	arches="amd64 i386"
    fi
    mkdir -p ${INSTALLER_DIR}/repo/conf
    mkdir -p ${INSTALLER_DIR}/repo/db
    mkdir -p ${INSTALLER_DIR}/repo/dists
    mkdir -p ${INSTALLER_DIR}/repo/pool
    cat - <<EOF > ${INSTALLER_DIR}/repo/conf/distributions
Origin: MDSplus Development Team
Label: MDSplus
Codename: MDSplus
Architectures: ${arches}
Components: alpha stable
Description: MDSplus packages
EOF
    if [ -d /sign_keys/jenkins/.gnupg ]
    then 
	echo "SignWith: MDSplus" >> ${INSTALLER_DIR}/repo/conf/distributions
    fi
    export HOME=/sign_keys/jenkins
    find ${INSTALLER_DIR}/${BRANCH}/DEBS -name "*${MAJOR}\.${MINOR}\.${RELEASE}_*" -exec \
	 reprepro -V --waitforlock 20 -b ${INSTALLER_DIR}/repo -C ${BRANCH} includedeb MDSplus {} \;
}

windows_cleanup() {
    rm -Rf /winbld/${tmpdir}
}

build_windows() {
    set -e
    tests_64=0
    tests_32=0
    MAKE=${MAKE:="env LANG=en_US.UTF-8 make"}

    JNI_INCLUDE_DIR=${SRCDIR}/3rd-party-apis/windows-jdk
    JNI_MD_INCLUDE_DIR=${SRCDIR}/3rd-party-apis/windows-jdk/win32
    MDSPLUS_DIR=${WORKSPACE}/buildroot;
    MDS_PATH=${MDSPLUS_DIR}/tdi;
    mkdir -p ${WORKSPACE}/64;
    mkdir -p ${MDSPLUS_DIR};
    pushd ${WORKSPACE}/64;
    ${SRCDIR}/configure  \
	     --prefix=${MDSPLUS_DIR} \
	     --exec_prefix=${MDSPLUS_DIR} \
	     --bindir=${MDSPLUS_DIR}/bin_x86_64 \
	     --libdir=${MDSPLUS_DIR}/bin_x86_64 \
	     --host=x86_64-w64-mingw32 \
	     --with-labview=${SRCDIR}/3rd-party-apis/labview \
	     --with-java_target=6 \
	     --with-java_bootclasspath=${SRCDIR}/rt.jar
    $MAKE
    $MAKE install
    if [ "${TESTS}" = "yes" ]
    then
	  set +e
	  echo " --- MAKING TESTS 64bit --- "
	  $MAKE -k tests TEST_FORMAT=tap
	  tests_64=$?
	  set -e
    fi
    popd
    mkdir -p ${WORKSPACE}/32;
    pushd ${WORKSPACE}/32;
    ${SRCDIR}/configure  \
	     --prefix=${MDSPLUS_DIR} \
	     --exec_prefix=${MDSPLUS_DIR} \
	     --bindir=${MDSPLUS_DIR}/bin_x86 \
	     --libdir=${MDSPLUS_DIR}/bin_x86 \
	     --host=i686-w64-mingw32 \
	     --with-labview=${SRCDIR}/3rd-party-apis/labview \
	     --with-java_target=6 \
	     --with-java_bootclasspath=${SRCDIR}/rt.jar
    $MAKE
    $MAKE install
    if [ "${TESTS}" = "yes" ]
    then
	  set +e
	  echo " --- MAKING TESTS 32bit --- "
	  $MAKE -k tests TEST_FORMAT=tap
	  tests_32=$?
	  set -e
    fi
    popd
    cd /winbld
    tmpdir=$(mktemp -d mdsplus-XXXXXXXXXX)
    trap windows_cleanup EXIT
    topsrcdir=${WINBLD_REMDIR}/${tmpdir}
    cd ${tmpdir}
    rsync -am --include="*/" --include="*.h*" --include="*.def" --exclude="*" ${SRCDIR}/ ./
    rsync -am ${WORKSPACE}/64/include/config.h ./include/
    rsync -a ${SRCDIR}/mdsobjects/cpp ${SRCDIR}/mdsobjects/MdsObjects* ${SRCDIR}/mdsobjects/VS-* ./mdsobjects/
    rsync -a ${SRCDIR}/deploy/winbld.bat ./deploy/
    rsync -a ${MDSPLUS_DIR}/bin_* ./
    curl http://${WINBLD_HOST}:8080${topsrcdir}/deploy/winbld.bat
    # see if files are there
    ls /winbld/${tmpdir}/bin_x86*/*.lib /winbld/${tmpdir}/bin_x86*/MdsObjectsCppShr-VS.* > /dev/null
    rsync -av --include="*/" --include="*.lib" --include="MdsObjectsCppShr-VS.dll" --exclude="*" /winbld/${tmpdir}/bin_x86* ${MDSPLUS_DIR}/
    mkdir -p ${DISTDIR}/winbld
    pushd ${MDSPLUS_DIR}
    tar zcf ${DISTDIR}/winbld/mdsplus-${BRANCH}.${MAJOR}.${MINOR}.${RELEASE}.tgz .
    popd
    tests_failed=0
    if [ "$tests_64" != "0" ]
    then
	tests_failed=1
	echo "64-bit tests failed"
    fi
    if [ "$tests_32" != "0" ]
    then
	tests_failed=1
	echo "64-bit tests failed"
    fi
    exit $tests_failed
}

publish_windows() {
    set -e
    cd ${WORKPACE}
    INSTALLER_DIR=${DISTDIR}/${DIST}
    mkdir -p ${INSTALLER_DIR}
    tar zxf ${DISTDIR}/winbld/mdsplus-${BRANCH}.${MAJOR}.${MINOR}.${RELEASE}.tgz
    makensis -DMAJOR=${MAJOR} -DMINOR=${MINOR} -DRELEASE=${RELEASE} -DFLAVOR=${BNAME} -NOCD \
             -DOUTDIR=${INSTALLER_DIR} -DVisualStudio ${SRCDIR}/deploy/mdsplus.nsi
    if [ -d /sign_keys ]
    then
	echo mdsplus | signcode -spc /sign_keys/mdsplus.spc \
				-v /sign_keys/mdsplus.pvk \
				-a sha1 \
				-$ individual \
				-n MDSplus  \
				-i http://www.mdsplus.org/ \
				-t http://timestamp.verisign.com/scripts/timestamp.dll \
				-tr 10 ${INSTALLER_DIR}/MDSplus${BNAME}-${MAJOR}.${MINOR}-${RELEASE}.exe
    fi
}

set -e
set -xv
if [ -f /.dockerinit ]
then
    export HOME=${WORKSPACE}
    source build.conf
    if [ "$(echo ${DIST} | grep -c 32)" = "1" -o "$(echo ${DIST} | grep -c 64)" = "1" ]
    then
	DIST=${DIST:0:-3}
    fi
    MAKE=${MAKE:="env LANG=en_US.UTF-8 make"};
    # note: the TRIGGER ${WORKSPACE} is /mdsplus/source in jenkins current configuration
    source /mdsplus/source/jenkins_build.conf
    if [ "$PUBLISH_RELEASE" = "yes" ]
    then
	DIST_TAG_FILE=${DISTDIR}/${DIST}/mdsplus-${BRANCH}-${MAJOR}.${MINOR}-${RELEASE}
    fi
    case ${DIST_TYPE} in
	redhat)
	    if [ "${TESTS}" = "yes" ]
	    then
		test_64;
		test_32;
		check_tests;
	    fi
            if [ "${MAKE_RELEASE}" = "yes" ]
            then
              RELEASE_DATE="$(date +"%B %e, %Y")"
	      build_64;
	      build_32;
	      build_rpms;
	    fi
	    if [ "${PUBLISH_RELEASE}" = "yes" ]
	    then
		build_rpm_repo;
		echo ${GIT_COMMIT} > ${DIST_TAG_FILE}
            fi;;
	debian)
	    if [ "${TESTS}" = "yes" ]
	    then
		if [ "$ARCH" = "i386" -o "$ARCH" = "armhf" ]
		then
		    test_32;
		else
		    test_64;
		fi
		check_tests;
	    fi
	    if [ "${MAKE_RELEASE}" = "yes" ]
	    then
		if [ "$ARCH" = "i386" -o "$ARCH" = "armhf" ]
		then
		    build_32;
		else
		    build_64;
		fi
		build_debs;
	    fi
	    if [ "${PUBLISH_RELEASE}" = "yes" ]
	    then
		build_deb_repo;
		echo ${GIT_COMMIT} > ${DIST_TAG_FILE}
 	    fi;;
	windows)
	    if [ "${MAKE_RELEASE}" = "yes" ]
	    then
		build_windows;
	    fi
	    if [ "${PUBLISH_RELEASE}" = "yes" ]
	    then
		publish_windows;
		echo ${GIT_COMMIT} > ${DIST_TAG_FILE}
 	    fi;;
	*)
	    echo Unknown DIST_TYPE: ${DIST_TYPE}
	    exit 1;;
    esac
else
    parse_cmd $@
    case "$OP" in
	BUILD)
	    if [ -z "$WORKSPACE" ]
	    then
		WORKSPACE=$(pwd)
	    fi
	    if [ -z "$SRCDIR" ]
	    then
		echo "Source directory not specified"
		print_help
		exit 1;
	    fi
	    source ${SRCDIR}/jenkins_build.conf
	    if [ "$MAKE_RELEASE" = "yes" -o "$PUBLISH_RELEASE" = "yes" ]
	    then
		installer_volume="-v ${DISTDIR}:${DISTDIR}"
		DIST_TAG_FILE=${DISTDIR}/${DIST}/mdsplus-${BRANCH}-${MAJOR}.${MINOR}-${RELEASE}
		if [ "$(cat ${DIST_TAG_FILE} 2>/dev/null)" = "${GIT_COMMIT}" ]
		then
		    echo "This release is already complete. Nothing else to do."
		    exit 0
		else
		    rm -f ${DISTDIR}:${DISTDIR}/mdsplus-${BRANCH}-*.*-*
		fi
	    fi
	    if [ "$MAKE_RELEASE" = "yes" ]
	    then
		mkdir -p ${WORKSPACE}/release
		if [ -z "${DISTDIR}" ]
		then
		    echo "Distribution directory not specified"
		    print_help
		    exit 1;
		fi
	    fi
	    if [ -z "$DOCKER_IMAGE" ]
	    then
		echo "Docker image not specified"
		print_help
		exit 1;
	    fi
	    IFS=',' read -ra DI_ARR <<< "$DOCKER_IMAGE"
	    images=0
            for DOCKER_IMAGE in "${DI_ARR[@]}"; do
		let images=images+1
		if [ $images -eq ${#DI_ARR[@]} ]; then
		    LAST_IMAGE=yes;
		else
		    LAST_IMAGE=no;
		fi;
		if [ ${LAST_IMAGE} = "no" -a "${PUBLISH_RELEASE}" = "yes" ]
		then
		    continue
		fi
		docker pull ${DOCKER_IMAGE}
		if [ "$TESTS" = "yes" -o "$VG_TESTS" != "" ]
		then
		    mkdir -p ${WORKSPACE}/tests
		else
		    rm -Rf ${WORKSPACE}/tests
		fi;
		if [ ! -z "$SIGN_KEYS" ]
		then
		    signkeys="-v ${SIGN_KEYS}:/sign_keys"
		fi
		if [ ! -z "$WINBLD" ]
		then
		    winbld_volume="-v ${WINBLD}:/winbld"
                fi
		docker run --name="${JOB_NAME}${BUILD_NUMBER}" \
		       --pid=host \
		       -t \
                       -u $(id -u):$(id -g) \
		       -v ${SRCDIR}:${SRCDIR} \
		       -v ${SRCDIR}:/mdsplus/source \
		       -v ${WORKSPACE}:${WORKSPACE} \
		       ${installer_volume} \
                       ${winbld_volume} \
                       -e "WINBLD_HOST=${WINBLD_HOST}" \
		       -e "WINBLD_REMDIR=${WINBLD_REMDIR}" \
		       -e "WORKSPACE=${WORKSPACE}" \
		       -e "SRCDIR=${SRCDIR}" \
		       -e "LAST_IMAGE=${LAST_IMAGE}" \
		       ${signkeys} \
		       ${DOCKER_IMAGE};
		docker rm "${JOB_NAME}${BUILD_NUMBER}";
	    done;;
	TRIGGER)
	    if [ "$MAKE_RELEASE" = "yes" -o "$PUBLISH_RELEASE" = "yes" ]
	    then
		BRANCH=${GIT_BRANCH:7};
		RELEASE_TAG=$(git tag | grep ${BRANCH}_release | sort -V | awk '{line=$0} END{print line}');
		if [ -z ${RELEASE_TAG} ]
		then
		    RELEASE_TAG="${BRANCH}_release-1-0-0"
		fi
		MAJOR=$(echo $RELEASE_TAG | cut -f2 -d-);
		MINOR=$(echo $RELEASE_TAG | cut -f3 -d-);
		RELEASE=$(echo $RELEASE_TAG | cut -f4 -d-);
		if [ "$BRANCH" = "stable" ]
		then
		    BNAME=""
		else
		    BNAME="-${BRANCH}"
		fi
		if [ "$(git rev-list -n 1 $RELEASE_TAG)" != "${GIT_COMMIT}" ]
		then
		    let RELEASE=$RELEASE+1;
		    RELEASE_TAG=${BRANCH}_release-${MAJOR}-${MINOR}-${RELEASE};
		    git log --decorate=full > ChangeLog;
		fi;
	    fi
	    cat - <<EOF > ${WORKSPACE}/jenkins_build.conf
export MAKE_RELEASE=$MAKE_RELEASE
export PUBLISH_RELEASE=$PUBLISH_RELEASE
export TESTS=$TESTS
export VG_TESTS="$VG_TESTS"
export SAN_TESTS="$SAN_TESTS"
export BRANCH=${BRANCH}
export BNAME=${BNAME}
export RELEASE_TAG=${RELEASE_TAG}
export MAJOR=${MAJOR}
export MINOR=${MINOR}
export RELEASE=${RELEASE}
export VERBOSE=${VERBOSE}
export DISTDIR=${DISTDIR}
export GIT_COMMIT=${GIT_COMMIT}
export SIGN_KEYS=${SIGN_KEYS}
EOF
	    ;;
	
	UPLOAD_TO_PYPI)
	    if ( test -r ${WORKSPACE}/jenkins_build.conf )
            then
		source ${WORKSPACE}/jenkins_build.conf
	    fi
	    if ( test "${RELEASE_TAG}" != "" )
	    then
		mkdir -p ${WORKSPACE}/pypi
		pushd ${WORKSPACE}/pypi
		${WORKSPACE}/configure
		popd
		for package in mdsobjects/python tdi/MitDevices tdi/RfxDevices tdi/W7xDevices; do
		    pushd ${WORKSPACE}/${package}
		    cp ${WORKSPACE}/pypi/${package}/_version.py ./
		    python setup.py sdist upload
		    rm _version.py
		    popd
		done
	    else
		cat <<EOF
Invalid command option. tag_release is only avaliable after 
a valid $0 trigger --release has been executed.
EOF
		exit 1;
	    fi;;
	    
	TAG_RELEASE)
	    set -e
            set -o verbose
	    if ( test -r ${WORKSPACE}/jenkins_build.conf )
            then
		source ${WORKSPACE}/jenkins_build.conf
	    fi
	    if ( test "${RELEASE_TAG}" != "" )
	    then
		comment=$(echo "New release of ${BRANCH} branch of MDSplus." \
		               "Version mdsplus${BNAME}-${MAJOR}-${MINOR}-${RELEASE}");
		git tag -f -a -m  "${comment}" ${RELEASE_TAG};
		git push --follow-tags origin ${BRANCH};
	    else
		cat <<EOF
Invalid command option. tag_release is only avaliable after 
a valid $0 trigger --release has been executed.
EOF
		exit 1;
	    fi;;
	*) echo "Unknown option";
	   exit 1;
	   ;;
    esac
fi
